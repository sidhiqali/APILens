// APILens 

APILens/
├── api/
│   ├── .env
│   ├── .env.example
│   ├── .gitignore
│   ├── .prettierrc
│   ├── api.log
│   ├── eslint.config.mjs
│   ├── nest-cli.json
│   ├── package.json
│   ├── README.md
│   ├── tsconfig.build.json
│   ├── tsconfig.json
│   ├── mocks/
│   │   ├── README.md
│   │   ├── openapi/
│   │   │   ├── chat/
│   │   │   │   └── v1-realtime.yaml
│   │   │   ├── enhanced/
│   │   │   ├── inventory/
│   │   │   │   ├── v1.yaml
│   │   │   │   └── v2.yaml
│   │   │   ├── iot/
│   │   │   │   └── v3-devices.yaml
│   │   │   ├── ml/
│   │   │   │   └── v2-platform.yaml
│   │   │   ├── notifications/
│   │   │   │   ├── v1.yaml
│   │   │   │   └── v2.yaml
│   │   │   ├── orders/
│   │   │   │   ├── v1.yaml
│   │   │   │   └── v2.yaml
│   │   │   ├── payments/
│   │   │   │   ├── v1-enhanced.yaml
│   │   │   │   ├── v1.yaml
│   │   │   │   └── v2.yaml
│   │   │   ├── users/
│   │   │   │   ├── v1-enhanced.yaml
│   │   │   │   ├── v1.yaml
│   │   │   │   └── v2.yaml
│   │   │   └── weather/
│   │   │       ├── v1.yaml
│   │   │       └── v2.yaml
│   │   ├── orchestrator/
│   │   │   ├── prismauto.config.js
│   │   │   └── start-mocks.js
│   │   ├── postman/
│   │   │   └── Mock-APIs-Direct-Testing.postman_collection.json
│   │   └── scripts/
│   │       ├── register-apis.js
│   │       └── validate-demo.js
│   ├── scripts/
│   ├── src/
│   │   ├── app.controller.spec.ts
│   │   ├── app.controller.ts
│   │   ├── app.module.ts
│   │   ├── app.service.ts
│   │   ├── main.ts
│   │   ├── common/
│   │   │   ├── filters/
│   │   │   │   └── http-exception.filter.ts
│   │   │   └── interceptors/
│   │   │       └── logging.interceptor.ts
│   │   ├── config/
│   │   │   └── configuration.ts
│   │   ├── gateways/
│   │   │   └── notifications.gateway.ts
│   │   ├── modules/
│   │   │   ├── apis/
│   │   │   │   ├── apis.controller.spec.ts
│   │   │   │   ├── apis.controller.ts
│   │   │   │   ├── apis.module.ts
│   │   │   │   ├── apis.service.spec.ts
│   │   │   │   ├── apis.service.ts
│   │   │   │   ├── change-detector.service.ts
│   │   │   │   └── dto/
│   │   │   ├── auth/
│   │   │   │   ├── auth.controller.ts
│   │   │   │   ├── auth.module.ts
│   │   │   │   ├── auth.service.spec.ts
│   │   │   │   ├── auth.service.ts
│   │   │   │   ├── dto/
│   │   │   │   ├── guards/
│   │   │   │   └── Strategy/
│   │   │   ├── changelogs/
│   │   │   │   ├── changelogs.controller.spec.ts
│   │   │   │   ├── changelogs.controller.ts
│   │   │   │   ├── changelogs.module.ts
│   │   │   │   ├── changelogs.service.spec.ts
│   │   │   │   └── changelogs.service.ts
│   │   │   ├── dashboard/
│   │   │   │   ├── dashboard.controller.ts
│   │   │   │   ├── dashboard.module.ts
│   │   │   │   ├── dashboard.service.ts
│   │   │   │   └── dto/
│   │   │   ├── health/
│   │   │   │   ├── health.controller.spec.ts
│   │   │   │   ├── health.controller.ts
│   │   │   │   ├── health.module.ts
│   │   │   │   ├── health.service.spec.ts
│   │   │   │   └── health.service.ts
│   │   │   ├── notifications/
│   │   │   │   ├── email.service.ts
│   │   │   │   ├── notifications.controller.spec.ts
│   │   │   │   └── ...
│   │   │   ├── schedules/
│   │   │   │   └── ...
│   │   │   ├── user/
│   │   │   │   └── ...
│   │   │   └── websocket/
│   │   │       └── ...
│   │   ├── Schemas/
│   │   │   ├── api-change.schema.ts
│   │   │   ├── api-snapshot.schema.ts
│   │   │   ├── api.schema.ts
│   │   │   ├── changelog-schema.ts
│   │   │   ├── notification.schema.ts
│   │   │   └── user.schema.ts
│   │   ├── types/
│   │   │   ├── api.type.ts
│   │   │   ├── auth.type.ts
│   │   │   ├── jwt.type.ts
│   │   │   └── user.type.ts
│   │   └── utils/
│   ├── test/
│   │   ├── app.e2e-spec.ts
│   │   └── jest-e2e.json
│   └── utils/
│       ├── api-diff.ts
│       └── user.ts
├── client/
│   ├── src/
│   │   ├── app/
│   │   │   ├── apis/
│   │   │   │   └── page.tsx
│   │   │   └── ...
│   │   ├── components/
│   │   │   ├── layout/
│   │   │   │   └── Layout.tsx
│   │   │   ├── search/
│   │   │   │   └── FilterPanel.tsx
│   │   │   └── RouteGuard.tsx
│   │   ├── hooks/
│   │   │   └── useApis.ts
│   │   ├── lib/
│   │   │   └── axios.ts
│   │   ├── providers/
│   │   │   └── WebSocketProvider.tsx
│   │   ├── services/
│   │   │   └── api.service.ts
│   │   └── types/
│   │       └── index.ts
│   └── ...
└── vscode/
    ├── package.json
    ├── README.md
    └── src/
        ├── extension.ts
        ├── handlers/
        │   └── FileContextMenuHandler.ts
        ├── providers/
        │   ├── APIDetailViewProvider.ts
        │   └── WebviewProvider.ts
        └── services/
            ├── APIService.ts
            └──


//Backend API Code

// DATABASE SCHEMAS
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true })
export class Api extends Document {
  @Prop({ required: true })
  apiName: string;

  @Prop({ required: true })
  openApiUrl: string;

  @Prop({ required: true })
  type: string;

  @Prop()
  version: string;

  @Prop({ type: Object })
  latestSpec: any;

  @Prop({ index: true })
  lastChecked: Date;

  @Prop({ type: Types.ObjectId, ref: 'User', required: true, index: true })
  userId: Types.ObjectId;

  @Prop({ default: '1h' })
  checkFrequency: string;

  @Prop({ default: true, index: true })
  isActive: boolean;

  @Prop({ type: [String], default: [], index: true })
  tags: string[];

  @Prop({ default: 'unknown', index: true })
  healthStatus: string;

  @Prop()
  lastHealthCheck: Date;

  @Prop({ index: true })
  lastError: string;

  @Prop({ default: 0 })
  changeCount: number;

  @Prop()
  description: string;
}

export const ApiSchema = SchemaFactory.createForClass(Api);

// Changelog Schema - stores API change history and version tracking

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true })
export class Changelog extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Api', required: true, index: true })
  apiId: Types.ObjectId;

  @Prop({ required: true })
  previousVersion: string;

  @Prop({ required: true })
  newVersion: string;

  @Prop({ required: true })
  diffSummary: string;

  @Prop({ default: Date.now, index: true })
  timestamp: Date;
}

export const ChangelogSchema = SchemaFactory.createForClass(Changelog);
ChangelogSchema.index({ apiId: 1, timestamp: -1 });
ChangelogSchema.index(
  { apiId: 1, previousVersion: 1, newVersion: 1 },
  { unique: true },
);
ChangelogSchema.index({ timestamp: -1 });

// Notification Schema - manages user notifications for API changes and alerts

@Schema({ timestamps: true })
export class Notification extends Document {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true, index: true })
  userId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Api', index: true })
  apiId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'ApiChange', index: true })
  changeId: Types.ObjectId;

  @Prop({
    required: true,
    enum: ['api_change', 'api_error', 'api_recovered', 'system'],
  })
  type: string;

  @Prop({ required: true })
  title: string;

  @Prop({ required: true })
  message: string;

  @Prop({
    required: true,
    enum: ['low', 'medium', 'high', 'critical'],
  })
  severity: string;

  @Prop({ default: false, index: true })
  read: boolean;

  @Prop()
  readAt: Date;

  @Prop({ type: Object })
  metadata: any;

  @Prop({ default: [] })
  channels: string[];

  @Prop({ default: [] })
  deliveryStatus: {
    channel: string;
    status: 'pending' | 'sent' | 'failed';
    sentAt?: Date;
    error?: string;
  }[];
}

export const NotificationSchema = SchemaFactory.createForClass(Notification);
NotificationSchema.index({ userId: 1, read: 1, createdAt: -1 });
NotificationSchema.index({ severity: 1, read: 1, createdAt: -1 });
NotificationSchema.index({ apiId: 1, createdAt: -1 });
NotificationSchema.index({ type: 1, createdAt: -1 });
NotificationSchema.index({ userId: 1, severity: 1, createdAt: -1 });

// User Schema - manages user accounts, authentication, and preferences

@Schema({ timestamps: true })
export class User extends Document {
  @Prop({ required: true, unique: true, index: true })
  email: string;

  @Prop({ required: true })
  password: string;

  @Prop({ default: 'user' })
  role: string;

  @Prop({ default: false })
  isEmailVerified: boolean;

  @Prop()
  emailVerificationToken: string;

  @Prop()
  emailVerificationExpires: Date;

  @Prop()
  passwordResetToken: string;

  @Prop()
  passwordResetExpires: Date;

  @Prop()
  refreshToken: string;

  @Prop()
  refreshTokenExpires: Date;

  @Prop()
  lastLoginAt: Date;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({
    type: Object,
    default: {
      email: true,
      breakingChanges: true,
      nonBreakingChanges: false,
      apiErrors: true,
    },
  })
  notificationPreferences: {
    email: boolean;
    breakingChanges: boolean;
    nonBreakingChanges: boolean;
    apiErrors: boolean;
  };

  @Prop()
  firstName: string;

  @Prop()
  lastName: string;

  @Prop()
  avatar: string;

  @Prop()
  timezone: string;

  @Prop({ default: 'en' })
  language: string;
}

export const UserSchema = SchemaFactory.createForClass(User);

// API Snapshot Schema - stores point-in-time snapshots of API specifications

@Schema({ timestamps: true })
export class ApiSnapshot extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Api', required: true, index: true })
  apiId: Types.ObjectId;

  @Prop({ required: true })
  version: string;

  @Prop({ type: Object, required: true })
  spec: any;

  @Prop({ required: true, index: true })
  detectedAt: Date;

  @Prop({ type: Object })
  metadata: {
    endpointCount?: number;
    schemaCount?: number;
    specSize?: number;
    checksum?: string;
  };
}

export const ApiSnapshotSchema = SchemaFactory.createForClass(ApiSnapshot);

// API Change Schema - tracks detailed changes between API versions

export interface ChangeDetail {
  path: string;
  changeType: 'added' | 'removed' | 'modified';
  oldValue?: any;
  newValue?: any;
  description: string;
}

@Schema({ timestamps: true })
export class ApiChange extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Api', required: true, index: true })
  apiId: Types.ObjectId;

  @Prop({ required: true })
  fromVersion: string;

  @Prop({ required: true })
  toVersion: string;

  @Prop({
    required: true,
    enum: ['breaking', 'non-breaking', 'deprecation', 'addition'],
  })
  changeType: string;

  @Prop({
    required: true,
    enum: ['low', 'medium', 'high', 'critical'],
  })
  severity: string;

  @Prop({ type: Array, required: true })
  changes: ChangeDetail[];

  @Prop({ required: true, index: true })
  detectedAt: Date;

  @Prop({ default: false })
  acknowledged: boolean;

  @Prop()
  acknowledgedAt: Date;

  @Prop({ type: Types.ObjectId, ref: 'User' })
  acknowledgedBy: Types.ObjectId;

  @Prop()
  summary: string;

  @Prop({ default: 0 })
  impactScore: number;
}

export const ApiChangeSchema = SchemaFactory.createForClass(ApiChange);
ApiChangeSchema.index({ apiId: 1, detectedAt: -1 });
ApiChangeSchema.index({ apiId: 1, acknowledged: 1 });
ApiChangeSchema.index({ severity: 1, acknowledged: 1 });
ApiChangeSchema.index({ changeType: 1, detectedAt: -1 });
ApiChangeSchema.index({ impactScore: -1, detectedAt: -1 });
ApiChangeSchema.index({ acknowledgedBy: 1, acknowledgedAt: -1 });

// MAIN APPLICATION

// Main Application Entry Point (main.ts) - configures NestJS application

import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';
import * as cookieParser from 'cookie-parser';
import helmet from 'helmet';
import { AllExceptionsFilter } from './common/filters/http-exception.filter';
import { LoggingInterceptor } from './common/interceptors/logging.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Security configuration with Helmet
  app.use(
    helmet({
      crossOriginEmbedderPolicy: false,
      contentSecurityPolicy: {
        directives: {
          imgSrc: [`'self'`, 'data:', 'https:'],
        },
      },
    }),
  );

  // CORS configuration for frontend and VS Code extension
  app.enableCors({
    origin: [
      process.env.FRONTEND_URL || 'http://localhost:3001',
      'vscode-webview://*',
      'http://localhost:3000',
    ],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'Accept'],
  });

  app.use(cookieParser());

  // Global validation pipe for request validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  app.useGlobalFilters(new AllExceptionsFilter());
  app.useGlobalInterceptors(new LoggingInterceptor());

  // Swagger API documentation configuration
  const config = new DocumentBuilder()
    .setTitle('API Lens')
    .setDescription('Local API for API change tracking and notifications')
    .setVersion('1.0.0')
    .addBearerAuth(
      {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        name: 'JWT',
        description: 'Enter JWT token',
        in: 'header',
      },
      'JWT-auth',
    )
    .addCookieAuth('access_token', {
      type: 'http',
      in: 'cookie',
      scheme: 'bearer',
    })
    .addTag('auth', 'Authentication and user management endpoints')
    .addTag('apis', 'API registration, monitoring, and management')
    .addTag('notifications', 'Notification management and preferences')
    .addTag('schedules', 'Scheduled monitoring and health checks')
    .addTag('health', 'System health and status endpoints')
    .addServer('http://localhost:3000', 'Local server')
    .build();

  const document = SwaggerModule.createDocument(app, config, {
    operationIdFactory: (controllerKey: string, methodKey: string) => methodKey,
  });

  SwaggerModule.setup('api/docs', app, document, {
    swaggerOptions: {
      persistAuthorization: true,
      displayRequestDuration: true,
      filter: true,
    },
    customSiteTitle: 'API Lens - Local API Docs',
  });

  const port = process.env.PORT || 3000;
  await app.listen(port);

  console.log(`🚀 Application is running on: http://localhost:${port}`);
  console.log(`📚 Swagger documentation: http://localhost:${port}/api/docs`);
  console.log(`🏥 Health check: http://localhost:${port}/health`);
}

bootstrap().catch((error) => {
  console.error('❌ Error starting application:', error);
  process.exit(1);
});

// App Module (app.module.ts) - main application module configuration

import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { ScheduleModule } from '@nestjs/schedule';
import { ThrottlerModule } from '@nestjs/throttler';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { AuthModule } from './modules/auth/auth.module';
import { ApisModule } from './modules/apis/apis.module';
import { ChangelogsModule } from './modules/changelogs/changelogs.module';
import { NotificationsModule } from './modules/notifications/notifications.module';
import { SchedulesModule } from './modules/schedules/schedules.module';
import { UserModule } from './modules/user/user.module';
import { DashboardModule } from './modules/dashboard/dashboard.module';
import { WebSocketModule } from './modules/websocket/websocket.module';
import configuration from './config/configuration';
import { HealthModule } from './modules/health/health.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      load: [configuration],
      envFilePath: [`.env.${process.env.NODE_ENV || 'development'}`, '.env'],
      validationOptions: {
        allowUnknown: true,
        abortEarly: true,
      },
    }),

    // Rate limiting configuration
    ThrottlerModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        throttlers: [
          {
            ttl:
              configService.get<number>('monitoring.rateLimitWindow') ?? 60000,
            limit: configService.get<number>('monitoring.rateLimitMax') ?? 100,
          },
        ],
      }),
    }),

    // Scheduling module for background tasks
    ScheduleModule.forRoot(),

    // MongoDB connection configuration
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: async (configService: ConfigService) => {
        const databaseOptions =
          (await configService.get('database.options')) || {};
        return {
          uri: configService.get<string>('database.uri'),
          ...databaseOptions,
        };
      },
    }),

    // Feature modules
    UserModule,
    AuthModule,
    ApisModule,
    ChangelogsModule,
    NotificationsModule,
    SchedulesModule,
    DashboardModule,
    HealthModule,
    WebSocketModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

// AUTHENTICATION

// Auth Service - handles user authentication, registration, and token management

import {
  Injectable,
  UnauthorizedException,
  BadRequestException,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { UserService } from '../user/user.service';
import * as bcrypt from 'bcrypt';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';

@Injectable()
export class AuthService {
  constructor(
    private readonly userService: UserService,
    private readonly jwtService: JwtService,
    private readonly configService: ConfigService,
    private readonly emailService: EmailService,
  ) {}

  async validateUser(email: string, password: string): Promise<UserDocument | null> {
    const user = await this.userService.findByEmail(email);
    if (user && user.isActive && (await bcrypt.compare(password, user.password))) {
      return user;
    }
    return null;
  }

  async register(email: string, password: string, role: string = 'user'): Promise<RegisterResponseDto> {
    const existingUser = await this.userService.findByEmail(email);
    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    const hashedPassword = await bcrypt.hash(password, 12);
    const emailVerificationToken = this.generateToken();
    const emailVerificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000);

    const userData: CreateUserData = {
      email,
      password: hashedPassword,
      role,
      emailVerificationToken,
      emailVerificationExpires,
      isEmailVerified: false,
    };

    const user = await this.userService.create(userData);
    this.sendVerificationEmail(email, emailVerificationToken);

    return {
      message: 'User registered successfully. Please check your email for verification link.',
      user: toSafeUser(user),
    };
  }

  async login(email: string, password: string): Promise<AuthResponseDto> {
    const user = await this.validateUser(email, password);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    if (!user.isEmailVerified) {
      throw new UnauthorizedException('Please verify your email before logging in');
    }

    await this.userService.updateLastLogin(user._id.toString());
    const tokens = this.generateTokens(user);

    await this.userService.updateRefreshToken(
      user._id.toString(),
      tokens.refreshToken,
      new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    );

    return {
      message: 'Login successful',
      user: toSafeUser(user),
      token: tokens.accessToken,
      refreshToken: tokens.refreshToken,
    };
  }

  private generateTokens(user: UserDocument): { accessToken: string; refreshToken: string } {
    const payload = { email: user.email, sub: user._id.toString() };

    const accessToken = this.jwtService.sign(payload, {
      secret: this.configService.get<string>('jwt.secret') || this.configService.get<string>('JWT_SECRET'),
      expiresIn: this.configService.get<string>('jwt.expiresIn') || '1h',
    });

    const refreshToken = this.jwtService.sign(payload, {
      secret: this.configService.get<string>('jwt.refreshSecret') || this.configService.get<string>('JWT_REFRESH_SECRET'),
      expiresIn: this.configService.get<string>('jwt.refreshExpiresIn') || '7d',
    });

    return { accessToken, refreshToken };
  }
  async forgotPassword(email: string): Promise<ForgotPasswordResponseDto> {
    const user = await this.userService.findByEmail(email);
    if (!user) {
      return {
        message: 'If an account with that email exists, we have sent a password reset link.',
        email,
      };
    }

    const resetToken = this.generateToken();
    const resetExpires = new Date(Date.now() + 60 * 60 * 1000);

    await this.userService.setPasswordResetToken(user._id.toString(), resetToken, resetExpires);
    this.sendPasswordResetEmail(email, resetToken);

    return {
      message: 'If an account with that email exists, we have sent a password reset link.',
      email,
    };
  }

  private generateToken(): string {
    return crypto.randomBytes(32).toString('hex');
  }
}

// API MANAGEMENT

// APIs Controller - handles HTTP requests for API management operations

import {
  Controller,
  Post,
  Get,
  Put,
  Delete,
  Param,
  Body,
  UseGuards,
  Request,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBody,
  ApiBearerAuth,
  ApiQuery,
  ApiParam,
} from '@nestjs/swagger';
import { ApisService } from './apis.service';
import { CreateApiDto } from './dto/create-api.dto';
import { UpdateApiDto } from './dto/update-api.dto';
import { ApiResponseDto } from './dto/api-response.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@ApiTags('apis')
@Controller('apis')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth('JWT-auth')
export class ApisController {
  constructor(
    private readonly apisService: ApisService,
    private readonly changeDetectorService: ChangeDetectorService,
    private readonly smartSchedulerService: SmartSchedulerService,
  ) {}
  @Post()
  @ApiOperation({
    summary: 'Register a new API for monitoring',
    description: 'Register a new API by providing its OpenAPI specification URL. The system will fetch the spec, validate it, and start monitoring for changes.',
  })
  @ApiBody({ type: CreateApiDto })
  @ApiResponse({
    status: 201,
    description: 'API registered successfully',
    type: ApiResponseDto,
  })
  async register(@Body() dto: CreateApiDto, @Request() req): Promise<ApiResponseDto> {
    return this.apisService.registerApi(dto, req.user.userId);
  }
  @Get()
  @ApiOperation({
    summary: 'Get all registered APIs',
    description: 'Retrieve all APIs registered by the current user. Optionally filter by tag.',
  })
  @ApiQuery({ name: 'tag', required: false, description: 'Filter APIs by tag' })
  @ApiResponse({ status: 200, description: 'List of APIs', type: [ApiResponseDto] })
  async getAll(@Request() req, @Query('tag') tag?: string): Promise<ApiResponseDto[]> {
    return this.apisService.getAllApis(req.user.userId, tag);
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get API by ID', description: 'Retrieve detailed information about a specific API' })
  @ApiParam({ name: 'id', description: 'API ID' })
  @ApiResponse({ status: 200, description: 'API details', type: ApiResponseDto })
  async getById(@Param('id') id: string, @Request() req): Promise<ApiResponseDto> {
    return this.apisService.getApiById(id, req.user.userId);
  }
  @Post(':id/check')
  @ApiOperation({ summary: 'Check API health', description: 'Manually trigger a health check for the API' })
  @ApiParam({ name: 'id', description: 'API ID' })
  @HttpCode(HttpStatus.OK)
  async checkApi(@Param('id') id: string, @Request() req): Promise<{ message: string }> {
    await this.apisService.checkApiHealth(id, req.user.userId);
    return { message: 'API health check initiated' };
  }

  // Toggle API active status
  @Put(':id/toggle-status')
  @ApiOperation({ summary: 'Toggle API status', description: 'Activate or deactivate API monitoring' })
  @ApiParam({ name: 'id', description: 'API ID' })
  async toggleStatus(@Param('id') id: string, @Request() req): Promise<ApiResponseDto> {
    return this.apisService.toggleApiStatus(id, req.user.userId);
  }

  // Delete API
  @Delete(':id')
  @ApiOperation({ summary: 'Delete API', description: 'Remove API from monitoring' })
  @ApiParam({ name: 'id', description: 'API ID' })
  @HttpCode(HttpStatus.NO_CONTENT)
  async delete(@Param('id') id: string, @Request() req): Promise<void> {
    await this.apisService.deleteApi(id, req.user.userId);
  }
}

// APIs Service - core business logic for API management

@Injectable()
export class ApisService {
  private readonly logger = new Logger(ApisService.name);

  constructor(
    @InjectModel(Api.name) private apiModel: Model<Api>,
    @InjectModel(Changelog.name) private changelogModel: Model<Changelog>,
    @InjectModel(ApiSnapshot.name) private snapshotModel: Model<ApiSnapshot>,
    @InjectModel(ApiChange.name) private apiChangeModel: Model<ApiChange>,
    private changeDetectorService: ChangeDetectorService,
    private notificationsService: NotificationsService,
  ) {}

  // Get all APIs for a user with change counts
  async getAllApis(userId: string, tag?: string): Promise<ApiResponseDto[]> {
    const userObjectId = new Types.ObjectId(userId);
    const filter: any = { userId: userObjectId };
    
    if (tag) {
      filter.tags = { $in: [tag] };
    }

    const apis = await this.apiModel
      .find(filter)
      .sort({ createdAt: -1 })
      .lean();

    // Calculate change counts for each API
    const apiIds = apis.map((api) => api._id);
    const changeCounts = await this.apiChangeModel.aggregate([
      { $match: { apiId: { $in: apiIds } } },
      { $group: { _id: '$apiId', count: { $sum: 1 } } },
    ]);

    const changeCountMap = new Map();
    changeCounts.forEach((item) => {
      changeCountMap.set(item._id.toString(), item.count);
    });

    const apisWithChangeCounts = apis.map((api) => ({
      ...api,
      changeCount: changeCountMap.get((api._id as any).toString()) || 0,
    }));

    return apisWithChangeCounts.map((api) => this.toResponseDto(api));
  }

  // Register new API for monitoring
  async registerApi(dto: CreateApiDto, userId: string): Promise<ApiResponseDto> {
    try {
      // Fetch OpenAPI specification
      const response: AxiosResponse<OpenAPISpec> = await axios.get(dto.openApiUrl, {
        timeout: 10000,
        headers: { 'User-Agent': 'API-Lens/1.0' },
      });

      const { info } = response.data;
      
      // Create API record in database
      const api = new this.apiModel({
        apiName: dto.apiName || info.title,
        openApiUrl: dto.openApiUrl,
        type: dto.type || 'REST',
        version: info.version,
        description: dto.description || info.description,
        userId: new Types.ObjectId(userId),
        latestSpec: response.data,
        lastChecked: new Date(),
        healthStatus: 'checking',
        tags: dto.tags || [],
        checkFrequency: dto.checkFrequency || '1h',
      });

      const savedApi = await api.save();
      
      // Create initial snapshot
      await this.createSnapshot(savedApi._id, info.version, response.data);
      
      // Perform initial health check
      this.performHealthCheck(savedApi).catch((error) => {
        this.logger.error(`Initial health check failed for API ${savedApi._id}:`, error);
      });

      return this.toResponseDto(savedApi);
    } catch (error) {
      this.logger.error('Failed to register API:', error);
      throw new BadRequestException('Failed to fetch or parse OpenAPI specification');
    }
  }

  // Check API health and detect changes
  async checkApiHealth(apiId: string, userId: string): Promise<void> {
    const api = await this.getApiById(apiId, userId);
    await this.performHealthCheck(api);
  }

  // Perform health check and change detection
  private async performHealthCheck(api: Api): Promise<void> {
    try {
      const response = await axios.get(api.openApiUrl, {
        timeout: 10000,
        headers: { 'User-Agent': 'API-Lens/1.0' },
      });

      const newSpec = response.data;
      const newVersion = newSpec.info?.version || 'unknown';

      // Update health status
      await this.apiModel.findByIdAndUpdate(api._id, {
        lastChecked: new Date(),
        healthStatus: 'healthy',
        lastError: null,
      });

      // Check for changes if we have a previous spec
      if (api.latestSpec && api.version !== newVersion) {
        const changes = await this.changeDetectorService.detectChanges(
          api.latestSpec,
          newSpec,
          api._id,
          api.version,
          newVersion,
        );

        if (changes.length > 0) {
          // Create snapshot for new version
          await this.createSnapshot(api._id, newVersion, newSpec);
          
          // Update API with new spec and version
          await this.apiModel.findByIdAndUpdate(api._id, {
            latestSpec: newSpec,
            version: newVersion,
            changeCount: api.changeCount + changes.length,
          });

          // Send notifications for changes
          await this.notificationsService.notifyApiChanges(api.userId, api._id, changes);
        }
      }
    } catch (error) {
      this.logger.error(`Health check failed for API ${api._id}:`, error);
      
      await this.apiModel.findByIdAndUpdate(api._id, {
        lastChecked: new Date(),
        healthStatus: 'unhealthy',
        lastError: error.message,
      });
    }
  }

  // Create snapshot of API specification
  private async createSnapshot(apiId: Types.ObjectId, version: string, spec: any): Promise<void> {
    const snapshot = new this.snapshotModel({
      apiId,
      version,
      spec,
      detectedAt: new Date(),
      metadata: {
        endpointCount: this.countEndpoints(spec),
        schemaCount: this.countSchemas(spec),
        specSize: JSON.stringify(spec).length,
        checksum: this.generateChecksum(spec),
      },
    });

    await snapshot.save();
  }

  // Helper method to count API endpoints
  private countEndpoints(spec: any): number {
    if (!spec.paths) return 0;
    return Object.keys(spec.paths).reduce((count, path) => {
      const pathItem = spec.paths[path];
      const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];
      return count + methods.filter(method => pathItem[method]).length;
    }, 0);
  }

  // Helper method to count schemas
  private countSchemas(spec: any): number {
    return spec.components?.schemas ? Object.keys(spec.components.schemas).length : 0;
  }

  // Generate checksum for spec comparison
  private generateChecksum(spec: any): string {
    return require('crypto').createHash('md5').update(JSON.stringify(spec)).digest('hex');
  }

  // Convert database model to response DTO
  private toResponseDto(api: any): ApiResponseDto {
    return {
      id: api._id.toString(),
      apiName: api.apiName,
      openApiUrl: api.openApiUrl,
      type: api.type,
      version: api.version,
      description: api.description,
      isActive: api.isActive,
      healthStatus: api.healthStatus,
      lastChecked: api.lastChecked,
      lastError: api.lastError,
      changeCount: api.changeCount || 0,
      tags: api.tags || [],
      checkFrequency: api.checkFrequency,
      createdAt: api.createdAt,
      updatedAt: api.updatedAt,
    };
  }

  // Advanced API validation and testing
  async testOpenApiUrl(url: string): Promise<{
    valid: boolean;
    accessible?: boolean;
    spec?: any;
    error?: string;
    metadata?: {
      title?: string;
      version?: string;
      description?: string;
      endpoints?: number;
    };
  }> {
    try {
      new URL(url);
      
      const response = await axios.get(url, {
        timeout: 15000,
        headers: {
          Accept: 'application/json, application/yaml, text/yaml, */*',
          'User-Agent': 'APILens/1.0.0',
        },
        validateStatus: (status) => status < 500,
      });

      if (response.status >= 400) {
        return {
          valid: false,
          accessible: false,
          error: `HTTP ${response.status}: ${response.statusText}`,
        };
      }

      let spec: any;
      const contentType = response.headers['content-type'] || '';

      // Parse JSON or YAML format
      try {
        if (contentType.includes('json') || response.data.toString().trim().startsWith('{')) {
          spec = typeof response.data === 'string' ? JSON.parse(response.data) : response.data;
        } else {
          spec = yaml.parse(response.data.toString());
        }
      } catch (parseError) {
        return {
          valid: false,
          accessible: true,
          error: `Failed to parse specification: ${parseError.message}`,
        };
      }

      // Validate OpenAPI/Swagger format
      const isOpenAPI3 = spec.openapi && spec.openapi.startsWith('3.');
      const isSwagger2 = spec.swagger && spec.swagger.startsWith('2.');

      if (!isOpenAPI3 && !isSwagger2) {
        return {
          valid: false,
          accessible: true,
          error: 'Not a valid OpenAPI/Swagger specification. Missing version field.',
        };
      }

      if (!spec.info || !spec.paths) {
        return {
          valid: false,
          accessible: true,
          error: 'Invalid specification: missing required sections',
        };
      }

      const metadata = {
        title: spec.info?.title || 'Untitled API',
        version: spec.info?.version || '1.0.0',
        description: spec.info?.description || '',
        endpoints: spec.paths ? Object.keys(spec.paths).length : 0,
      };

      return {
        valid: true,
        accessible: true,
        spec: {
          info: spec.info,
          openapi: spec.openapi,
          swagger: spec.swagger,
          paths: spec.paths ? Object.keys(spec.paths) : [],
          components: spec.components ? Object.keys(spec.components) : [],
        },
        metadata,
      };
    } catch (error) {
      if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
        return {
          valid: false,
          accessible: false,
          error: `Cannot connect to ${url}. Please check the URL and try again.`,
        };
      }
      return {
        valid: false,
        accessible: false,
        error: error.message,
      };
    }
  }

  // Bulk operations for multiple APIs
  async bulkToggleStatus(ids: string[], userId: string): Promise<void> {
    const apis = await this.apiModel.find({
      _id: { $in: ids },
      userId: userId,
    });

    const bulkOps = apis.map((api) => ({
      updateOne: {
        filter: { _id: api._id },
        update: { isActive: !api.isActive },
      },
    }));

    if (bulkOps.length > 0) {
      await this.apiModel.bulkWrite(bulkOps);
    }
  }

  async bulkDelete(ids: string[], userId: string): Promise<void> {
    await this.apiModel.deleteMany({
      _id: { $in: ids },
      userId: userId,
    });

    await this.changelogModel.deleteMany({ apiId: { $in: ids } });
  }

  // Advanced health management
  async fixHealthStatuses(userId: Types.ObjectId): Promise<{ message: string; updated: number }> {
    try {
      const result = await this.apiModel.updateMany(
        { userId },
        {
          $set: {
            healthStatus: 'healthy',
            lastChecked: new Date(),
            lastHealthCheck: new Date(),
          },
        },
      );

      return {
        message: `Successfully updated ${result.modifiedCount} APIs`,
        updated: result.modifiedCount,
      };
    } catch (error) {
      throw new Error(`Failed to fix health statuses: ${error.message}`);
    }
  }

  async initializeApiHealthStatuses(): Promise<void> {
    const allApis = await this.apiModel.find({});
    let needsUpdate = 0;

    for (const api of allApis) {
      const needsHealthUpdate = !api.healthStatus || api.healthStatus === 'unknown' || !api.lastChecked;

      if (needsHealthUpdate) {
        needsUpdate++;
        const initialStatus = api.isActive ? 'healthy' : 'inactive';

        await this.apiModel.findByIdAndUpdate(api._id, {
          healthStatus: initialStatus,
          lastChecked: new Date(),
          lastHealthCheck: new Date(),
        });
      }
    }
  }

  // Health scoring and monitoring
  async updateApiHealthScores(): Promise<void> {
    const apis = await this.apiModel.find({ isActive: true });

    for (const api of apis) {
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

      const recentSnapshots = await this.snapshotModel
        .find({
          apiId: api._id,
          detectedAt: { $gte: sevenDaysAgo },
        })
        .sort({ detectedAt: -1 });

      if (recentSnapshots.length > 0) {
        const totalDays = 7;
        const daysWithSnapshots = new Set(
          recentSnapshots.map(
            (snapshot) => snapshot.detectedAt.toISOString().split('T')[0],
          ),
        ).size;

        const healthScore = (daysWithSnapshots / totalDays) * 100;
        let finalScore = Math.round(healthScore);

        if (api.healthStatus === 'healthy') {
          finalScore = Math.min(100, finalScore + 20);
        } else if (api.healthStatus === 'error') {
          finalScore = Math.max(0, finalScore - 30);
        }

        await this.apiModel.findByIdAndUpdate(api._id, {
          healthScore: finalScore,
          lastHealthUpdate: new Date(),
        });
      }
    }
  }

  // Advanced health checking with smart interval detection
  async getApisToCheck(): Promise<Api[]> {
    const now = new Date();
    const apis = await this.apiModel.find({ isActive: true });

    return apis.filter((api) => {
      if (!api.lastChecked) return true;

      const timeSinceLastCheck = now.getTime() - api.lastChecked.getTime();
      const checkInterval = this.getCheckIntervalMs(api.checkFrequency);

      return timeSinceLastCheck >= checkInterval;
    });
  }

  private getCheckIntervalMs(frequency: string): number {
    const intervals = {
      '30s': 30 * 1000,
      '1m': 60 * 1000,
      '5m': 5 * 60 * 1000,
      '15m': 15 * 60 * 1000,
      '1h': 60 * 60 * 1000,
      '6h': 6 * 60 * 60 * 1000,
      '1d': 24 * 60 * 60 * 1000,
    };
    return intervals[frequency] || intervals['1h'];
  }

  // Comprehensive health issue analysis
  async getApiHealthIssues(id: string, userId: string): Promise<any> {
    const api = await this.apiModel
      .findById(id)
      .select('_id userId apiName healthStatus lastError lastChecked')
      .lean();

    if (!api) {
      throw new NotFoundException('API not found');
    }
    if (api.userId.toString() !== userId) {
      throw new ForbiddenException('Access denied');
    }

    const issues: any[] = [];

    if (api.healthStatus === 'unhealthy' || api.healthStatus === 'error') {
      const recentChanges = await this.apiChangeModel
        .find({ apiId: new Types.ObjectId(id) })
        .select('changeType severity changes detectedAt summary')
        .sort({ detectedAt: -1 })
        .limit(5)
        .lean();

      if (api.lastError) {
        issues.push({
          id: 'api_error',
          type: 'availability',
          severity: 'critical',
          title: 'API Connection Failed',
          description: api.lastError,
          timestamp: api.lastChecked,
          details: {
            metric: 'availability',
            current: 0,
            threshold: 100,
            suggestions: [
              'Check if the API server is running',
              'Verify the OpenAPI URL is accessible',
              'Check network connectivity',
            ],
          },
        });
      }

      if (recentChanges.length > 0) {
        const breakingChanges = recentChanges.filter(
          (change) => change.changeType === 'breaking',
        );

        if (breakingChanges.length > 0) {
          issues.push({
            id: 'breaking_changes',
            type: 'breaking_change',
            severity: 'high',
            title: 'Breaking Changes Detected',
            description: `${breakingChanges.length} breaking changes found in recent updates`,
            timestamp: breakingChanges[0].detectedAt,
            details: {
              changes: breakingChanges[0].changes,
              affectedEndpoints: breakingChanges[0].changes
                .map((c) => c.path)
                .filter((path) => path.includes('/')),
              suggestions: [
                'Review API documentation for migration guide',
                'Update client applications to handle changes',
                'Consider API versioning strategy',
              ],
            },
          });
        }
      }
    }

    return {
      apiId: id,
      apiName: api.apiName,
      healthStatus: api.healthStatus,
      issueCount: issues.length,
      issues,
      lastChecked: api.lastChecked,
    };
  }

  // Data management and cleanup
  async cleanupOldSnapshots(): Promise<number> {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const result = await this.snapshotModel.deleteMany({
      detectedAt: { $lt: thirtyDaysAgo },
    });

    return result.deletedCount;
  }

  // Advanced change detection with health endpoint monitoring
  async checkApiForChanges(apiId: string): Promise<{
    hasChanges: boolean;
    changes?: any[];
    newVersion?: string;
  }> {
    const api = await this.apiModel.findById(apiId);
    if (!api || !api.isActive) {
      return { hasChanges: false };
    }

    try {
      await this.apiModel.findByIdAndUpdate(apiId, {
        healthStatus: 'checking',
        lastHealthCheck: new Date(),
      });

      const response = await axios.get(api.openApiUrl, {
        timeout: 10000,
        headers: { 'User-Agent': 'API-Lens/1.0' },
      });

      const newSpec = response.data;
      const oldSpec = api.latestSpec;

      // Check health endpoint
      const baseUrl = api.openApiUrl
        .replace(/\/[^/]*\.json.*$/, '')
        .replace(/\/[^/]*\.yaml.*$/, '');

      let healthStatus = 'healthy';
      let healthErrorMessage: string | undefined;

      try {
        const healthUrl = `${baseUrl}/health`;
        const healthResponse = await axios.get(healthUrl, { timeout: 5000 });

        if (healthResponse.status >= 500) {
          healthStatus = 'error';
          healthErrorMessage = `Health endpoint returned ${healthResponse.status}`;
        } else if (healthResponse.status >= 400) {
          healthStatus = 'unhealthy';
          healthErrorMessage = `Health endpoint returned ${healthResponse.status}`;
        }
      } catch (healthError) {
        if (healthError.response?.status) {
          const statusCode = healthError.response.status;
          healthStatus = statusCode >= 500 ? 'error' : statusCode >= 400 ? 'unhealthy' : 'healthy';
        } else {
          healthStatus = 'error';
        }
        healthErrorMessage = healthError.message;
      }

      // Detect changes in specification
      const changeResult = await this.changeDetectorService.detectChanges(
        oldSpec,
        newSpec,
        apiId,
      );

      // Update health status
      const previousHealthStatus = api.healthStatus;
      await this.apiModel.findByIdAndUpdate(apiId, {
        healthStatus,
        lastChecked: new Date(),
        lastHealthCheck: new Date(),
        lastError: healthErrorMessage || null,
      });

      // Notify health status changes
      if (previousHealthStatus && previousHealthStatus !== healthStatus) {
        await this.createHealthStatusNotification(
          apiId,
          api.apiName,
          previousHealthStatus,
          healthStatus,
          healthErrorMessage,
        );
      }

      if (changeResult.hasChanges) {
        await this.apiModel.findByIdAndUpdate(apiId, {
          latestSpec: newSpec,
          version: newSpec.info?.version || api.version,
          changeCount: api.changeCount + 1,
        });

        await this.createSnapshot(apiId, newSpec);

        await this.notificationsService.notifyApiChanges(
          apiId,
          changeResult.changes,
          newSpec.info?.version,
        );

        return {
          hasChanges: true,
          changes: changeResult.changes,
          newVersion: newSpec.info?.version,
        };
      }

      return { hasChanges: false };
    } catch (error) {
      const previousHealthStatus = api.healthStatus;

      await this.apiModel.findByIdAndUpdate(apiId, {
        healthStatus: 'error',
        lastHealthCheck: new Date(),
        lastError: error.message,
      });

      if (previousHealthStatus !== 'error') {
        await this.notificationsService.notifyApiError(apiId, error.message);
      }

      return { hasChanges: false };
    }
  }

  // Health status notification system
  private async createHealthStatusNotification(
    apiId: string,
    apiName: string,
    oldStatus: string,
    newStatus: string,
    errorMessage?: string,
  ) {
    try {
      if (newStatus === 'healthy' && oldStatus !== 'healthy') {
        await this.notificationsService.notifyApiRecovered(apiId);
      } else if (newStatus === 'unhealthy' || newStatus === 'error') {
        const message = errorMessage || 'API endpoint is not responding properly';
        await this.notificationsService.notifyApiError(apiId, message);
      }
    } catch (error) {
      this.logger.error(
        `Failed to create health status notification for ${apiName}: ${error.message}`,
      );
    }
  }
}

// DASHBOARD & ANALYTICS

// Dashboard Service - provides comprehensive analytics and statistics

@Injectable()
export class DashboardService {
  private readonly logger = new Logger(DashboardService.name);

  constructor(
    @InjectModel(Api.name) private apiModel: Model<Api>,
    @InjectModel(ApiChange.name) private apiChangeModel: Model<ApiChange>,
    @InjectModel(Notification.name) private notificationModel: Model<Notification>,
    @InjectModel(User.name) private userModel: Model<User>,
  ) {}

  // Get comprehensive dashboard overview with all metrics
  async getDashboardOverview(userId: string): Promise<DashboardOverviewDto> {
    const [stats, recentActivity, apiHealthSummary, criticalAlerts] = await Promise.all([
      this.getDashboardStats(userId),
      this.getRecentActivity(userId, 10),
      this.getApiHealthSummary(userId),
      this.getCriticalAlerts(userId, 5),
    ]);

    return { stats, recentActivity, apiHealthSummary, criticalAlerts };
  }

  // Calculate comprehensive dashboard statistics
  async getDashboardStats(userId: string): Promise<DashboardStatsDto> {
    const userObjectId = new Types.ObjectId(userId);
    const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);

    // Get basic API counts
    const [totalApis, activeApis, healthyApis, unhealthyApis] = await Promise.all([
      this.apiModel.countDocuments({ userId: userObjectId }),
      this.apiModel.countDocuments({ userId: userObjectId, isActive: true }),
      this.apiModel.countDocuments({ userId: userObjectId, healthStatus: 'healthy' }),
      this.apiModel.countDocuments({ userId: userObjectId, healthStatus: { $in: ['unhealthy', 'error'] } }),
    ]);

    // Get user's API IDs for change calculations
    const userApis = await this.apiModel.find({ userId: userObjectId }, '_id').lean();
    const apiIds = userApis.map((api: any) => api._id);

    // Calculate change statistics
    const [totalChanges, recentChanges, breakingChanges, nonBreakingChanges] = await Promise.all([
      this.apiChangeModel.countDocuments({ apiId: { $in: apiIds } }),
      this.apiChangeModel.countDocuments({
        apiId: { $in: apiIds },
        detectedAt: { $gte: sevenDaysAgo },
      }),
      this.apiChangeModel.countDocuments({
        apiId: { $in: apiIds },
        detectedAt: { $gte: thirtyDaysAgo },
        changeType: 'breaking',
      }),
      this.apiChangeModel.countDocuments({
        apiId: { $in: apiIds },
        detectedAt: { $gte: thirtyDaysAgo },
        changeType: { $ne: 'breaking' },
      }),
    ]);

    // Calculate critical issues
    const criticalIssues = await this.apiModel.countDocuments({
      userId: userObjectId,
      $or: [{ healthStatus: 'error' }, { changeCount: { $gt: 5 } }],
    });

    // Get notification statistics
    const [totalNotifications, unreadNotifications, recentNotifications] = await Promise.all([
      this.notificationModel.countDocuments({ userId: userObjectId }),
      this.notificationModel.countDocuments({ userId: userObjectId, read: false }),
      this.notificationModel.countDocuments({
        userId: userObjectId,
        createdAt: { $gte: sevenDaysAgo },
      }),
    ]);

    // Find most active API
    const mostActiveApiResult = await this.apiModel
      .findOne({ userId: userObjectId })
      .sort({ changeCount: -1 })
      .select('_id apiName changeCount')
      .lean();

    const mostActiveApi = mostActiveApiResult ? {
      id: (mostActiveApiResult._id as any).toString(),
      name: mostActiveApiResult.apiName,
      changeCount: mostActiveApiResult.changeCount || 0,
    } : null;

    // Calculate uptime percentage
    const healthStats = await this.apiModel.aggregate([
      { $match: { userId: userObjectId, isActive: true } },
      {
        $group: {
          _id: null,
          healthyCount: { $sum: { $cond: [{ $eq: ['$healthStatus', 'healthy'] }, 1, 0] } },
          totalCount: { $sum: 1 },
        },
      },
    ]);

    const healthResult = healthStats[0] || { healthyCount: 0, totalCount: 0 };
    const uptimePercentage = healthResult.totalCount > 0 
      ? Math.round((healthResult.healthyCount / healthResult.totalCount) * 100) 
      : 0;

    return {
      totalApis,
      activeApis,
      healthyApis,
      unhealthyApis,
      totalChanges,
      criticalIssues,
      recentChanges,
      breakingChanges,
      nonBreakingChanges,
      totalNotifications,
      unreadNotifications,
      recentNotifications,
      mostActiveApi,
      uptimePercentage,
    };
  }

  // Get recent activity across APIs and notifications
  async getRecentActivity(userId: string, limit: number = 10): Promise<RecentActivityDto[]> {
    const userObjectId = new Types.ObjectId(userId);

    // Get user's APIs for mapping
    const userApis = await this.apiModel.find({ userId: userObjectId }, '_id apiName').lean();
    const apiIds = userApis.map((api: any) => api._id);
    const apiMap = new Map(userApis.map((api: any) => [api._id.toString(), api.apiName]));

    // Get recent changes and notifications
    const [recentChanges, recentNotifications] = await Promise.all([
      this.apiChangeModel.find({ apiId: { $in: apiIds } }).sort({ detectedAt: -1 }).limit(limit).lean(),
      this.notificationModel.find({ userId: userObjectId }).sort({ createdAt: -1 }).limit(limit).lean(),
    ]);

    const activities: RecentActivityDto[] = [];

    // Process API changes
    recentChanges.forEach((change: any) => {
      const apiId = change.apiId.toString();
      activities.push({
        id: change._id.toString(),
        type: 'api_change',
        title: 'API Change Detected',
        description: `${change.changes?.length || 0} changes in ${apiMap.get(apiId) || 'Unknown API'}`,
        timestamp: change.detectedAt,
        apiId,
        apiName: apiMap.get(apiId),
        severity: this.mapSeverity(change.severity),
      });
    });

    // Process notifications
    recentNotifications.forEach((notification: any) => {
      const apiId = notification.apiId?.toString();
      activities.push({
        id: notification._id.toString(),
        type: 'notification',
        title: notification.title,
        description: notification.message,
        timestamp: notification.createdAt,
        apiId,
        apiName: apiId ? apiMap.get(apiId) : undefined,
        severity: this.mapSeverity(notification.severity),
      });
    });

    return activities
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit);
  }

  // Get API health summary for dashboard
  async getApiHealthSummary(userId: string): Promise<ApiHealthSummaryDto[]> {
    const userObjectId = new Types.ObjectId(userId);

    const apis = await this.apiModel
      .find({ userId: userObjectId })
      .select('_id apiName healthStatus lastChecked changeCount isActive')
      .sort({ lastChecked: -1 })
      .lean();

    return apis.map((api: any) => ({
      id: api._id.toString(),
      name: api.apiName,
      status: this.mapHealthStatus(api.healthStatus),
      lastChecked: api.lastChecked || new Date(),
      changeCount: api.changeCount || 0,
      isActive: api.isActive !== false,
    }));
  }

  // Advanced analytics - API changes trend over time
  async getApiChangesTrend(userId: string, days: number = 30): Promise<{ date: string; count: number }[]> {
    const userObjectId = new Types.ObjectId(userId);
    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);

    const userApis = await this.apiModel
      .find({ userId: userObjectId }, '_id')
      .lean();
    const apiIds = userApis.map((api: any) => api._id);

    const trend = await this.apiChangeModel.aggregate([
      {
        $match: {
          apiId: { $in: apiIds },
          detectedAt: { $gte: startDate },
        },
      },
      {
        $group: {
          _id: {
            $dateToString: {
              format: '%Y-%m-%d',
              date: '$detectedAt',
            },
          },
          count: { $sum: 1 },
        },
      },
      {
        $sort: { _id: 1 },
      },
    ]);

    return trend.map((item: any) => ({
      date: item._id,
      count: item.count,
    }));
  }

  // Get critical alerts for immediate attention
  async getCriticalAlerts(userId: string, limit: number = 5): Promise<RecentActivityDto[]> {
    const userObjectId = new Types.ObjectId(userId);

    const userApis = await this.apiModel.find({ userId: userObjectId }, '_id apiName').lean();
    const apiIds = userApis.map((api: any) => api._id);
    const apiMap = new Map(userApis.map((api: any) => [api._id.toString(), api.apiName]));

    const criticalAlerts: RecentActivityDto[] = [];

    // Get critical changes
    const criticalChanges = await this.apiChangeModel
      .find({
        apiId: { $in: apiIds },
        $or: [{ severity: 'critical' }, { changeType: 'breaking' }],
      })
      .sort({ detectedAt: -1 })
      .limit(limit)
      .lean();

    criticalChanges.forEach((change: any) => {
      const apiId = change.apiId.toString();
      criticalAlerts.push({
        id: change._id.toString(),
        type: 'api_change',
        title: 'Critical API Change',
        description: `Breaking change detected in ${apiMap.get(apiId) || 'Unknown API'}`,
        timestamp: change.detectedAt,
        apiId,
        apiName: apiMap.get(apiId),
        severity: 'critical',
      });
    });

    // Get unhealthy APIs
    const unhealthyApis = await this.apiModel
      .find({
        userId: userObjectId,
        healthStatus: { $in: ['unhealthy', 'error'] },
      })
      .sort({ lastChecked: -1 })
      .limit(limit)
      .lean();

    unhealthyApis.forEach((api: any) => {
      const apiId = api._id.toString();
      criticalAlerts.push({
        id: apiId,
        type: 'api_health',
        title: 'API Health Issue',
        description: `${api.apiName} is ${api.healthStatus}`,
        timestamp: api.lastChecked || new Date(),
        apiId,
        apiName: api.apiName,
        severity: 'high',
      });
    });

    return criticalAlerts
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit);
  }

  private mapSeverity(severity: string): 'low' | 'medium' | 'high' | 'critical' {
    switch (severity) {
      case 'critical': return 'critical';
      case 'high': return 'high';
      case 'medium': return 'medium';
      case 'low':
      default: return 'low';
    }
  }

  private mapHealthStatus(status: string): 'healthy' | 'unhealthy' | 'checking' | 'error' {
    switch (status) {
      case 'healthy': return 'healthy';
      case 'unhealthy': return 'unhealthy';
      case 'error': return 'error';
      case 'checking':
      default: return 'checking';
    }
  }
}

// CHANGE DETECTION & MONITORING

// Change Detector Service - detects differences between API specifications

@Injectable()
export class ChangeDetectorService {
  private readonly logger = new Logger(ChangeDetectorService.name);

  constructor(
    @InjectModel(ApiChange.name) private apiChangeModel: Model<ApiChange>,
  ) {}

  // Main method to detect changes between two API specifications
  async detectChanges(
    oldSpec: any,
    newSpec: any,
    apiId: Types.ObjectId,
    fromVersion: string,
    toVersion: string,
  ): Promise<ApiChange[]> {
    const changes: ChangeDetail[] = [];
    
    // Compare paths (endpoints)
    const pathChanges = this.comparePaths(oldSpec.paths || {}, newSpec.paths || {});
    changes.push(...pathChanges);
    
    // Compare schemas
    const schemaChanges = this.compareSchemas(
      oldSpec.components?.schemas || {},
      newSpec.components?.schemas || {}
    );
    changes.push(...schemaChanges);
    
    // Compare info section
    const infoChanges = this.compareInfo(oldSpec.info || {}, newSpec.info || {});
    changes.push(...infoChanges);

    if (changes.length === 0) {
      return [];
    }

    // Group changes by type and severity
    const groupedChanges = this.groupChangesBySeverity(changes);
    const apiChanges: ApiChange[] = [];

    for (const [changeType, changeList] of Object.entries(groupedChanges)) {
      if (changeList.length > 0) {
        const severity = this.determineSeverity(changeType as any, changeList);
        const summary = this.generateChangeSummary(changeType as any, changeList);
        const impactScore = this.calculateImpactScore(changeList);

        const apiChange = new this.apiChangeModel({
          apiId,
          fromVersion,
          toVersion,
          changeType,
          severity,
          changes: changeList,
          detectedAt: new Date(),
          summary,
          impactScore,
          acknowledged: false,
        });

        const savedChange = await apiChange.save();
        apiChanges.push(savedChange);
      }
    }

    return apiChanges;
  }

  // Compare API paths/endpoints
  private comparePaths(oldPaths: any, newPaths: any): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    const oldPathKeys = Object.keys(oldPaths);
    const newPathKeys = Object.keys(newPaths);

    // Detect removed paths
    oldPathKeys.forEach(path => {
      if (!newPaths[path]) {
        changes.push({
          path: `paths.${path}`,
          changeType: 'removed',
          oldValue: oldPaths[path],
          description: `Endpoint '${path}' was removed`,
        });
      }
    });

    // Detect added paths
    newPathKeys.forEach(path => {
      if (!oldPaths[path]) {
        changes.push({
          path: `paths.${path}`,
          changeType: 'added',
          newValue: newPaths[path],
          description: `New endpoint '${path}' was added`,
        });
      }
    });

    // Detect modified paths
    oldPathKeys.forEach(path => {
      if (newPaths[path]) {
        const pathChanges = this.comparePathItem(oldPaths[path], newPaths[path], path);
        changes.push(...pathChanges);
      }
    });

    return changes;
  }

  // Compare individual path items (HTTP methods)
  private comparePathItem(oldPath: any, newPath: any, pathName: string): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    const methods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];

    methods.forEach(method => {
      const oldMethod = oldPath[method];
      const newMethod = newPath[method];

      if (oldMethod && !newMethod) {
        changes.push({
          path: `paths.${pathName}.${method}`,
          changeType: 'removed',
          oldValue: oldMethod,
          description: `Method '${method.toUpperCase()}' was removed from '${pathName}'`,
        });
      } else if (!oldMethod && newMethod) {
        changes.push({
          path: `paths.${pathName}.${method}`,
          changeType: 'added',
          newValue: newMethod,
          description: `Method '${method.toUpperCase()}' was added to '${pathName}'`,
        });
      } else if (oldMethod && newMethod) {
        // Compare parameters, responses, etc.
        const methodChanges = this.compareOperation(oldMethod, newMethod, `${pathName}.${method}`);
        changes.push(...methodChanges);
      }
    });

    return changes;
  }

  // Compare operation details (parameters, responses, etc.)
  private compareOperation(oldOp: any, newOp: any, operationPath: string): ChangeDetail[] {
    const changes: ChangeDetail[] = [];

    // Compare parameters
    if (oldOp.parameters || newOp.parameters) {
      const paramChanges = this.compareParameters(
        oldOp.parameters || [],
        newOp.parameters || [],
        operationPath
      );
      changes.push(...paramChanges);
    }

    // Compare responses
    if (oldOp.responses || newOp.responses) {
      const responseChanges = this.compareResponses(
        oldOp.responses || {},
        newOp.responses || {},
        operationPath
      );
      changes.push(...responseChanges);
    }

    return changes;
  }

  // Compare parameters
  private compareParameters(oldParams: any[], newParams: any[], operationPath: string): ChangeDetail[] {
    const changes: ChangeDetail[] = [];

    // Create maps for easier comparison
    const oldParamMap = new Map(oldParams.map(p => [`${p.name}-${p.in}`, p]));
    const newParamMap = new Map(newParams.map(p => [`${p.name}-${p.in}`, p]));

    // Check for removed parameters
    oldParamMap.forEach((param, key) => {
      if (!newParamMap.has(key)) {
        changes.push({
          path: `${operationPath}.parameters.${param.name}`,
          changeType: 'removed',
          oldValue: param,
          description: `Parameter '${param.name}' (${param.in}) was removed`,
        });
      }
    });

    // Check for added parameters
    newParamMap.forEach((param, key) => {
      if (!oldParamMap.has(key)) {
        changes.push({
          path: `${operationPath}.parameters.${param.name}`,
          changeType: 'added',
          newValue: param,
          description: `Parameter '${param.name}' (${param.in}) was added`,
        });
      }
    });

    return changes;
  }

  // Group changes by severity level
  private groupChangesBySeverity(changes: ChangeDetail[]): Record<string, ChangeDetail[]> {
    const groups = {
      breaking: [],
      'non-breaking': [],
      addition: [],
      deprecation: [],
    };

    changes.forEach(change => {
      if (change.changeType === 'removed') {
        groups.breaking.push(change);
      } else if (change.changeType === 'added') {
        groups.addition.push(change);
      } else {
        groups['non-breaking'].push(change);
      }
    });

    return groups;
  }

  // Determine severity based on change type and content
  private determineSeverity(changeType: string, changes: ChangeDetail[]): 'low' | 'medium' | 'high' | 'critical' {
    if (changeType === 'breaking') {
      return 'critical';
    } else if (changeType === 'deprecation') {
      return 'high';
    } else if (changeType === 'non-breaking') {
      return 'medium';
    } else {
      return 'low';
    }
  }

  // Generate human-readable summary
  private generateChangeSummary(changeType: string, changes: ChangeDetail[]): string {
    const count = changes.length;
    switch (changeType) {
      case 'breaking':
        return `${count} breaking change${count > 1 ? 's' : ''} detected`;
      case 'addition':
        return `${count} new feature${count > 1 ? 's' : ''} added`;
      case 'deprecation':
        return `${count} feature${count > 1 ? 's' : ''} deprecated`;
      default:
        return `${count} modification${count > 1 ? 's' : ''} made`;
    }
  }

  // Calculate impact score based on changes
  private calculateImpactScore(changes: ChangeDetail[]): number {
    return changes.reduce((score, change) => {
      switch (change.changeType) {
        case 'removed': return score + 10;
        case 'modified': return score + 5;
        case 'added': return score + 1;
        default: return score;
      }
    }, 0);
  }

  // Advanced change analysis with comprehensive comparison
  async detectChanges(oldSpec: any, newSpec: any, apiId: string): Promise<{
    hasChanges: boolean;
    changes: ChangeDetail[];
    severity: 'low' | 'medium' | 'high' | 'critical';
    changeType: 'breaking' | 'non-breaking' | 'deprecation' | 'addition';
    summary: string;
  }> {
    const changes: ChangeDetail[] = [];
    let severity: 'low' | 'medium' | 'high' | 'critical' = 'low';
    let changeType: 'breaking' | 'non-breaking' | 'deprecation' | 'addition' = 'non-breaking';

    // Detect version changes
    const versionChanges = this.detectVersionChanges(oldSpec, newSpec);
    changes.push(...versionChanges);

    // Detect path changes (endpoints)
    const pathChanges = this.detectPathChanges(oldSpec, newSpec);
    changes.push(...pathChanges);

    // Detect schema changes
    const schemaChanges = this.detectSchemaChanges(oldSpec, newSpec);
    changes.push(...schemaChanges);

    // Detect security changes
    const securityChanges = this.detectSecurityChanges(oldSpec, newSpec);
    changes.push(...securityChanges);

    // Analyze change impact
    const analysis = this.analyzeChanges(changes);
    severity = analysis.severity;
    changeType = analysis.changeType;

    if (changes.length > 0) {
      await this.saveApiChange(
        apiId,
        oldSpec.info?.version || 'unknown',
        newSpec.info?.version || 'unknown',
        changes,
        severity,
        changeType,
      );

      return {
        hasChanges: true,
        changes,
        severity,
        changeType,
        summary: this.generateSummary(changes),
      };
    }

    return {
      hasChanges: false,
      changes: [],
      severity: 'low',
      changeType: 'non-breaking',
      summary: 'No changes detected',
    };
  }

  // Detailed version comparison
  private detectVersionChanges(oldSpec: any, newSpec: any): ChangeDetail[] {
    const changes: ChangeDetail[] = [];

    if (oldSpec.info?.version !== newSpec.info?.version) {
      changes.push({
        path: 'info.version',
        changeType: 'modified',
        oldValue: oldSpec.info?.version,
        newValue: newSpec.info?.version,
        description: `Version updated from ${oldSpec.info?.version} to ${newSpec.info?.version}`,
      });
    }

    if (oldSpec.info?.title !== newSpec.info?.title) {
      changes.push({
        path: 'info.title',
        changeType: 'modified',
        oldValue: oldSpec.info?.title,
        newValue: newSpec.info?.title,
        description: `API title changed from "${oldSpec.info?.title}" to "${newSpec.info?.title}"`,
      });
    }

    return changes;
  }

  // Advanced path comparison with HTTP method analysis
  private detectPathChanges(oldSpec: any, newSpec: any): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    const oldPaths = Object.keys(oldSpec.paths || {});
    const newPaths = Object.keys(newSpec.paths || {});

    // Detect removed paths (breaking changes)
    const removedPaths = oldPaths.filter((path) => !newPaths.includes(path));
    removedPaths.forEach((path) => {
      changes.push({
        path: `paths.${path}`,
        changeType: 'removed',
        oldValue: oldSpec.paths[path],
        description: `Endpoint removed: ${path}`,
      });
    });

    // Detect added paths (new features)
    const addedPaths = newPaths.filter((path) => !oldPaths.includes(path));
    addedPaths.forEach((path) => {
      changes.push({
        path: `paths.${path}`,
        changeType: 'added',
        newValue: newSpec.paths[path],
        description: `New endpoint added: ${path}`,
      });
    });

    // Detect modified paths
    const commonPaths = oldPaths.filter((path) => newPaths.includes(path));
    commonPaths.forEach((path) => {
      const methodChanges = this.detectMethodChanges(
        oldSpec.paths[path],
        newSpec.paths[path],
        path,
      );
      changes.push(...methodChanges);
    });

    return changes;
  }

  // HTTP method comparison with parameter analysis
  private detectMethodChanges(oldPath: any, newPath: any, pathName: string): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    const httpMethods = ['get', 'post', 'put', 'delete', 'patch', 'options', 'head'];

    httpMethods.forEach((method) => {
      const oldMethod = oldPath[method];
      const newMethod = newPath[method];

      if (oldMethod && !newMethod) {
        changes.push({
          path: `paths.${pathName}.${method}`,
          changeType: 'removed',
          oldValue: oldMethod,
          description: `HTTP method ${method.toUpperCase()} removed from ${pathName}`,
        });
      } else if (!oldMethod && newMethod) {
        changes.push({
          path: `paths.${pathName}.${method}`,
          changeType: 'added',
          newValue: newMethod,
          description: `HTTP method ${method.toUpperCase()} added to ${pathName}`,
        });
      } else if (oldMethod && newMethod) {
        // Compare parameters
        const paramChanges = this.detectParameterChanges(
          oldMethod.parameters || [],
          newMethod.parameters || [],
          `${pathName}.${method}`,
        );
        changes.push(...paramChanges);

        // Compare responses
        const responseChanges = this.detectResponseChanges(
          oldMethod.responses || {},
          newMethod.responses || {},
          `${pathName}.${method}`,
        );
        changes.push(...responseChanges);
      }
    });

    return changes;
  }

  // Parameter change detection (critical for breaking changes)
  private detectParameterChanges(oldParams: any[], newParams: any[], methodPath: string): ChangeDetail[] {
    const changes: ChangeDetail[] = [];

    // Check for removed required parameters (breaking changes)
    oldParams.forEach((oldParam) => {
      if (oldParam.required) {
        const stillExists = newParams.find(
          (p) => p.name === oldParam.name && p.in === oldParam.in,
        );
        if (!stillExists) {
          changes.push({
            path: `paths.${methodPath}.parameters.${oldParam.name}`,
            changeType: 'removed',
            oldValue: oldParam,
            description: `Required parameter '${oldParam.name}' removed from ${methodPath}`,
          });
        }
      }
    });

    // Check for new required parameters (breaking changes)
    newParams.forEach((newParam) => {
      if (newParam.required) {
        const existedBefore = oldParams.find(
          (p) => p.name === newParam.name && p.in === newParam.in,
        );
        if (!existedBefore) {
          changes.push({
            path: `paths.${methodPath}.parameters.${newParam.name}`,
            changeType: 'added',
            newValue: newParam,
            description: `New required parameter '${newParam.name}' added to ${methodPath}`,
          });
        }
      }
    });

    return changes;
  }

  // Response structure analysis
  private detectResponseChanges(oldResponses: any, newResponses: any, methodPath: string): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    const oldCodes = Object.keys(oldResponses);
    const newCodes = Object.keys(newResponses);

    const removedCodes = oldCodes.filter((code) => !newCodes.includes(code));
    removedCodes.forEach((code) => {
      changes.push({
        path: `paths.${methodPath}.responses.${code}`,
        changeType: 'removed',
        oldValue: oldResponses[code],
        description: `Response code ${code} removed from ${methodPath}`,
      });
    });

    const addedCodes = newCodes.filter((code) => !oldCodes.includes(code));
    addedCodes.forEach((code) => {
      changes.push({
        path: `paths.${methodPath}.responses.${code}`,
        changeType: 'added',
        newValue: newResponses[code],
        description: `New response code ${code} added to ${methodPath}`,
      });
    });

    return changes;
  }

  // Schema structure comparison
  private detectSchemaChanges(oldSpec: any, newSpec: any): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    const oldSchemas = oldSpec.components?.schemas || {};
    const newSchemas = newSpec.components?.schemas || {};

    const oldSchemaNames = Object.keys(oldSchemas);
    const newSchemaNames = Object.keys(newSchemas);

    const removedSchemas = oldSchemaNames.filter((name) => !newSchemaNames.includes(name));
    removedSchemas.forEach((name) => {
      changes.push({
        path: `components.schemas.${name}`,
        changeType: 'removed',
        oldValue: oldSchemas[name],
        description: `Schema '${name}' removed`,
      });
    });

    const addedSchemas = newSchemaNames.filter((name) => !oldSchemaNames.includes(name));
    addedSchemas.forEach((name) => {
      changes.push({
        path: `components.schemas.${name}`,
        changeType: 'added',
        newValue: newSchemas[name],
        description: `New schema '${name}' added`,
      });
    });

    return changes;
  }

  // Security requirements analysis
  private detectSecurityChanges(oldSpec: any, newSpec: any): ChangeDetail[] {
    const changes: ChangeDetail[] = [];

    const oldSecurity = JSON.stringify(oldSpec.security || []);
    const newSecurity = JSON.stringify(newSpec.security || []);

    if (oldSecurity !== newSecurity) {
      changes.push({
        path: 'security',
        changeType: 'modified',
        oldValue: oldSpec.security,
        newValue: newSpec.security,
        description: 'Security requirements changed',
      });
    }

    return changes;
  }

  // Smart change impact analysis
  private analyzeChanges(changes: ChangeDetail[]): {
    severity: 'low' | 'medium' | 'high' | 'critical';
    changeType: 'breaking' | 'non-breaking' | 'deprecation' | 'addition';
  } {
    let severity: 'low' | 'medium' | 'high' | 'critical' = 'low';
    let changeType: 'breaking' | 'non-breaking' | 'deprecation' | 'addition' = 'non-breaking';

    const hasRemovals = changes.some((c) => c.changeType === 'removed');
    const hasRequiredParameterChanges = changes.some(
      (c) => c.path.includes('parameters') && c.description.includes('required'),
    );
    const hasSecurityChanges = changes.some((c) => c.path.includes('security'));

    if (hasRemovals || hasRequiredParameterChanges) {
      severity = 'high';
      changeType = 'breaking';
    } else if (hasSecurityChanges) {
      severity = 'medium';
      changeType = 'breaking';
    } else if (changes.some((c) => c.changeType === 'added')) {
      severity = 'low';
      changeType = 'addition';
    }

    return { severity, changeType };
  }

  // Generate human-readable summary
  private generateSummary(changes: ChangeDetail[]): string {
    const added = changes.filter((c) => c.changeType === 'added').length;
    const removed = changes.filter((c) => c.changeType === 'removed').length;
    const modified = changes.filter((c) => c.changeType === 'modified').length;

    const parts: string[] = [];
    if (added > 0) parts.push(`${added} addition${added > 1 ? 's' : ''}`);
    if (removed > 0) parts.push(`${removed} removal${removed > 1 ? 's' : ''}`);
    if (modified > 0) parts.push(`${modified} modification${modified > 1 ? 's' : ''}`);

    return parts.length > 0 ? parts.join(', ') : 'No significant changes';
  }

  // Persistent change tracking
  private async saveApiChange(
    apiId: string,
    fromVersion: string,
    toVersion: string,
    changes: ChangeDetail[],
    severity: 'low' | 'medium' | 'high' | 'critical',
    changeType: 'breaking' | 'non-breaking' | 'deprecation' | 'addition',
  ): Promise<void> {
    try {
      const impactScore = this.calculateImpactScore(changes, severity);

      await this.apiChangeModel.create({
        apiId: new Types.ObjectId(apiId),
        fromVersion,
        toVersion,
        changeType,
        severity,
        changes,
        detectedAt: new Date(),
        summary: this.generateSummary(changes),
        impactScore,
        acknowledged: false,
      });
    } catch (error) {
      this.logger.error(`Failed to save API change: ${error.message}`);
    }
  }

  private calculateImpactScore(changes: ChangeDetail[], severity: string): number {
    const severityScores = { low: 10, medium: 30, high: 60, critical: 100 };
    const baseScore = severityScores[severity];
    const removalCount = changes.filter((c) => c.changeType === 'removed').length;
    const additionCount = changes.filter((c) => c.changeType === 'added').length;
    return Math.min(100, baseScore + removalCount * 20 + additionCount * 5);
  }

  // Change history with user access control
  async getApiChangeHistory(apiId: string, userId: string, limit: number = 20): Promise<any[]> {
    const api = await this.apiModel.findById(apiId).select('_id userId').lean();
    if (!api) {
      throw new NotFoundException('API not found');
    }
    if (api.userId.toString() !== userId) {
      throw new ForbiddenException('Access denied');
    }

    return await this.apiChangeModel
      .find({ apiId: new Types.ObjectId(apiId) })
      .select('_id apiId changeType severity detectedAt summary changes')
      .sort({ detectedAt: -1 })
      .limit(limit)
      .lean();
  }
}

// NOTIFICATIONS

// Notifications Service - manages user notifications for API changes

@Injectable()
export class NotificationsService {
  private readonly logger = new Logger(NotificationsService.name);

  constructor(
    @InjectModel(Notification.name) private notificationModel: Model<Notification>,
    @InjectModel(User.name) private userModel: Model<User>,
    private emailService: EmailService,
  ) {}

  // Send notifications when API changes are detected
  async notifyApiChanges(userId: Types.ObjectId, apiId: Types.ObjectId, changes: ApiChange[]): Promise<void> {
    const user = await this.userModel.findById(userId);
    if (!user || !user.isActive) {
      return;
    }

    for (const change of changes) {
      // Check if user wants notifications for this type of change
      if (this.shouldNotifyUser(user, change)) {
        await this.createNotification({
          userId,
          apiId,
          changeId: change._id,
          type: 'api_change',
          title: 'API Change Detected',
          message: change.summary,
          severity: change.severity,
          metadata: {
            changeType: change.changeType,
            impactScore: change.impactScore,
            changeCount: change.changes.length,
          },
        });
      }
    }
  }

  // Multi-channel notification system with delivery tracking
  async notifyApiChanges(apiId: string, changes: ChangeDetail[], newVersion?: string): Promise<void> {
    try {
      const api = await this.apiModel.findById(apiId).populate('userId');
      if (!api) return;

      const user = await this.userModel.findById(api.userId);
      if (!user) return;

      const severity = this.determineSeverity(changes);
      const isBreaking = changes.some((c) => c.changeType === 'removed');

      if (!this.shouldNotifyUser(user, severity, isBreaking)) {
        return;
      }

      const title = this.generateChangeTitle(api.apiName, changes, newVersion);
      const message = this.generateChangeMessage(changes);

      const notificationData = {
        userId: api.userId.toString(),
        apiId,
        type: 'api_change' as const,
        title,
        message,
        severity,
        metadata: {
          changesCount: changes.length,
          newVersion,
          breakingChanges: isBreaking,
          changes: changes.slice(0, 5),
        },
        channels: this.getNotificationChannels(user, severity),
      };

      await this.createAndSendNotification(notificationData);
    } catch (error) {
      this.logger.error(`Failed to notify API changes: ${error.message}`);
    }
  }

  async notifyApiError(apiId: string, errorMessage: string): Promise<void> {
    try {
      const api = await this.apiModel.findById(apiId);
      if (!api) return;

      const user = await this.userModel.findById(api.userId);
      if (!user || !user.notificationPreferences?.apiErrors) {
        return;
      }

      const notificationData = {
        userId: api.userId.toString(),
        apiId,
        type: 'api_error' as const,
        title: `API Error: ${api.apiName}`,
        message: `Failed to check API: ${errorMessage}`,
        severity: 'high' as const,
        metadata: { error: errorMessage },
        channels: ['in-app', 'email'],
      };

      await this.createAndSendNotification(notificationData);
    } catch (error) {
      this.logger.error(`Failed to notify API error: ${error.message}`);
    }
  }

  async notifyApiRecovered(apiId: string): Promise<void> {
    try {
      const api = await this.apiModel.findById(apiId);
      if (!api) return;

      const user = await this.userModel.findById(api.userId);
      if (!user) return;

      const notificationData = {
        userId: api.userId.toString(),
        apiId,
        type: 'api_recovered' as const,
        title: `API Recovered: ${api.apiName}`,
        message: `API is now responding normally`,
        severity: 'low' as const,
        metadata: {},
        channels: ['in-app'],
      };

      await this.createAndSendNotification(notificationData);
    } catch (error) {
      this.logger.error(`Failed to notify API recovery: ${error.message}`);
    }
  }

  // Advanced notification creation with multi-channel delivery
  private async createAndSendNotification(data: any): Promise<void> {
    try {
      const notification = await this.notificationModel.create({
        userId: new Types.ObjectId(data.userId),
        apiId: data.apiId ? new Types.ObjectId(data.apiId) : undefined,
        changeId: data.changeId ? new Types.ObjectId(data.changeId) : undefined,
        type: data.type,
        title: data.title,
        message: data.message,
        severity: data.severity,
        metadata: data.metadata,
        channels: data.channels || ['in-app'],
        deliveryStatus: (data.channels || ['in-app']).map((channel) => ({
          channel,
          status: 'pending',
        })),
      });

      // Real-time notification via WebSocket
      this.notificationsGateway.broadcastNotification(data.userId, {
        id: (notification._id as any).toString(),
        userId: data.userId,
        apiId: data.apiId,
        type: data.type,
        title: data.title,
        message: data.message,
        severity: data.severity,
        metadata: data.metadata,
        createdAt: new Date().toISOString(),
      });

      // Send to each channel with delivery tracking
      for (const channel of data.channels || ['in-app']) {
        try {
          await this.sendNotificationToChannel(notification, channel, data);
        } catch (error) {
          await this.updateDeliveryStatus(
            (notification._id as any).toString(),
            channel,
            'failed',
            error.message,
          );
        }
      }
    } catch (error) {
      this.logger.error(`Failed to create notification: ${error.message}`);
    }
  }

  // Multi-channel delivery system
  private async sendNotificationToChannel(notification: any, channel: string, data: any): Promise<void> {
    switch (channel) {
      case 'email':
        await this.sendEmailNotification(notification, data);
        break;
      case 'webhook':
        await this.sendWebhookNotification(notification);
        break;
      case 'in-app':
        await this.updateDeliveryStatus(notification._id.toString(), channel, 'sent');
        break;
      default:
        this.logger.warn(`Unknown notification channel: ${channel}`);
    }
  }

  private async sendEmailNotification(notification: any, data: any): Promise<void> {
    const user = await this.userModel.findById(data.userId);
    if (!user) return;

    this.emailService.sendChangeNotification({
      to: user.email,
      subject: data.title,
      message: data.message,
      severity: data.severity,
      metadata: data.metadata,
    });

    await this.updateDeliveryStatus(notification._id.toString(), 'email', 'sent');
  }

  private async updateDeliveryStatus(
    notificationId: string,
    channel: string,
    status: 'pending' | 'sent' | 'failed',
    error?: string,
  ): Promise<void> {
    await this.notificationModel.findByIdAndUpdate(
      notificationId,
      {
        $set: {
          'deliveryStatus.$[elem].status': status,
          'deliveryStatus.$[elem].sentAt': new Date(),
          'deliveryStatus.$[elem].error': error,
        },
      },
      {
        arrayFilters: [{ 'elem.channel': channel }],
      },
    );
  }

  // Enhanced notification analytics
  async getNotificationStats(userId: string): Promise<{
    total: number;
    unread: number;
    byType: Record<string, number>;
    bySeverity: Record<string, number>;
  }> {
    const userObjectId = new Types.ObjectId(userId);

    const [total, unread, byType, bySeverity] = await Promise.all([
      this.notificationModel.countDocuments({ userId: userObjectId }),
      this.notificationModel.countDocuments({ userId: userObjectId, read: false }),
      this.notificationModel.aggregate([
        { $match: { userId: userObjectId } },
        { $group: { _id: '$type', count: { $sum: 1 } } },
      ]),
      this.notificationModel.aggregate([
        { $match: { userId: userObjectId } },
        { $group: { _id: '$severity', count: { $sum: 1 } } },
      ]),
    ]);

    return {
      total,
      unread,
      byType: byType.reduce((acc, item) => ({ ...acc, [item._id]: item.count }), {}),
      bySeverity: bySeverity.reduce((acc, item) => ({ ...acc, [item._id]: item.count }), {}),
    };
  }

  // Smart notification preferences
  private shouldNotifyUser(user: any, severity: string, isBreaking: boolean): boolean {
    const prefs = user.notificationPreferences || {};

    if (!prefs.email) return false;
    if (isBreaking && !prefs.breakingChanges) return false;
    if (!isBreaking && !prefs.nonBreakingChanges) return false;

    return true;
  }

  private generateChangeTitle(apiName: string, changes: ChangeDetail[], newVersion?: string): string {
    const changeCount = changes.length;
    const versionText = newVersion ? ` (v${newVersion})` : '';
    return `${apiName} Updated${versionText} - ${changeCount} change${changeCount > 1 ? 's' : ''}`;
  }

  private generateChangeMessage(changes: ChangeDetail[]): string {
    const summary = changes
      .slice(0, 3)
      .map((c) => `• ${c.description}`)
      .join('\n');
    const moreText = changes.length > 3 ? `\n...and ${changes.length - 3} more changes` : '';
    return `${summary}${moreText}`;
  }

  private getNotificationChannels(user: any, severity: string): string[] {
    const channels = ['in-app'];
    if (user.notificationPreferences?.email) {
      channels.push('email');
    }
    if (severity === 'high' || severity === 'critical') {
      channels.push('webhook');
    }
    return channels;
  }

  // Create a new notification
  async createNotification(data: {
    userId: Types.ObjectId;
    apiId?: Types.ObjectId;
    changeId?: Types.ObjectId;
    type: string;
    title: string;
    message: string;
    severity: string;
    metadata?: any;
  }): Promise<Notification> {
    const notification = new this.notificationModel({
      ...data,
      channels: ['app'], // Default to in-app notifications
      deliveryStatus: [{ channel: 'app', status: 'sent', sentAt: new Date() }],
    });

    const savedNotification = await notification.save();

    // Send email if user has email notifications enabled
    const user = await this.userModel.findById(data.userId);
    if (user?.notificationPreferences?.email) {
      await this.sendEmailNotification(user, savedNotification);
    }

    return savedNotification;
  }

  // Check if user should be notified based on preferences
  private shouldNotifyUser(user: any, change: ApiChange): boolean {
    const prefs = user.notificationPreferences;
    
    if (change.changeType === 'breaking' && prefs.breakingChanges) {
      return true;
    }
    
    if (change.changeType !== 'breaking' && prefs.nonBreakingChanges) {
      return true;
    }
    
    if (change.severity === 'critical' && prefs.apiErrors) {
      return true;
    }

    return false;
  }

  // Send email notification
  private async sendEmailNotification(user: any, notification: Notification): Promise<void> {
    try {
      await this.emailService.sendChangeNotificationEmail({
        to: user.email,
        subject: notification.title,
        title: notification.title,
        message: notification.message,
        severity: notification.severity,
        metadata: notification.metadata,
      });

      // Update delivery status
      await this.notificationModel.findByIdAndUpdate(notification._id, {
        $push: {
          deliveryStatus: {
            channel: 'email',
            status: 'sent',
            sentAt: new Date(),
          },
        },
      });
    } catch (error) {
      this.logger.error('Failed to send email notification:', error);
      
      await this.notificationModel.findByIdAndUpdate(notification._id, {
        $push: {
          deliveryStatus: {
            channel: 'email',
            status: 'failed',
            error: error.message,
          },
        },
      });
    }
  }

  // Get notifications for a user
  async getNotifications(
    userId: string,
    options: {
      limit?: number;
      offset?: number;
      unreadOnly?: boolean;
    } = {},
  ): Promise<{ notifications: Notification[]; total: number }> {
    const { limit = 20, offset = 0, unreadOnly = false } = options;
    const userObjectId = new Types.ObjectId(userId);

    const filter: any = { userId: userObjectId };
    if (unreadOnly) {
      filter.read = false;
    }

    const [notifications, total] = await Promise.all([
      this.notificationModel
        .find(filter)
        .sort({ createdAt: -1 })
        .limit(limit)
        .skip(offset)
        .populate('apiId', 'apiName')
        .lean(),
      this.notificationModel.countDocuments(filter),
    ]);

    return { notifications, total };
  }

  // Mark notification as read
  async markAsRead(notificationId: string, userId: string): Promise<void> {
    await this.notificationModel.findOneAndUpdate(
      { _id: notificationId, userId: new Types.ObjectId(userId) },
      { read: true, readAt: new Date() },
    );
  }

  // Mark all notifications as read
  async markAllAsRead(userId: string): Promise<void> {
    await this.notificationModel.updateMany(
      { userId: new Types.ObjectId(userId), read: false },
      { read: true, readAt: new Date() },
    );
  }
}

// UTILITIES

// API Diff Utility - helper functions for comparing API specifications

export class ApiDiffUtil {
  // Deep comparison of two objects
  static deepCompare(obj1: any, obj2: any, path: string = ''): ChangeDetail[] {
    const changes: ChangeDetail[] = [];
    
    if (typeof obj1 !== typeof obj2) {
      changes.push({
        path,
        changeType: 'modified',
        oldValue: obj1,
        newValue: obj2,
        description: `Type changed from ${typeof obj1} to ${typeof obj2}`,
      });
      return changes;
    }

    if (obj1 === null || obj2 === null) {
      if (obj1 !== obj2) {
        changes.push({
          path,
          changeType: 'modified',
          oldValue: obj1,
          newValue: obj2,
          description: `Value changed from ${obj1} to ${obj2}`,
        });
      }
      return changes;
    }

    if (typeof obj1 === 'object' && typeof obj2 === 'object') {
      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);
      const allKeys = new Set([...keys1, ...keys2]);

      allKeys.forEach(key => {
        const newPath = path ? `${path}.${key}` : key;
        
        if (!(key in obj1)) {
          changes.push({
            path: newPath,
            changeType: 'added',
            newValue: obj2[key],
            description: `Property '${key}' was added`,
          });
        } else if (!(key in obj2)) {
          changes.push({
            path: newPath,
            changeType: 'removed',
            oldValue: obj1[key],
            description: `Property '${key}' was removed`,
          });
        } else {
          const nestedChanges = this.deepCompare(obj1[key], obj2[key], newPath);
          changes.push(...nestedChanges);
        }
      });
    } else if (obj1 !== obj2) {
      changes.push({
        path,
        changeType: 'modified',
        oldValue: obj1,
        newValue: obj2,
        description: `Value changed from '${obj1}' to '${obj2}'`,
      });
    }

    return changes;
  }

  // Generate checksum for API specification
  static generateChecksum(spec: any): string {
    const crypto = require('crypto');
    const normalizedSpec = this.normalizeSpec(spec);
    return crypto.createHash('sha256').update(JSON.stringify(normalizedSpec)).digest('hex');
  }

  // Normalize API spec for consistent comparison
  private static normalizeSpec(spec: any): any {
    const normalized = { ...spec };
    
    // Remove metadata that doesn't affect API contract
    delete normalized.externalDocs;
    delete normalized.servers;
    
    // Sort objects by keys for consistent comparison
    if (normalized.paths) {
      normalized.paths = this.sortObjectByKeys(normalized.paths);
    }
    
    if (normalized.components?.schemas) {
      normalized.components.schemas = this.sortObjectByKeys(normalized.components.schemas);
    }

    return normalized;
  }

  // Sort object keys recursively
  private static sortObjectByKeys(obj: any): any {
    if (typeof obj !== 'object' || obj === null || Array.isArray(obj)) {
      return obj;
    }

    const sorted = {};
    Object.keys(obj)
      .sort()
      .forEach(key => {
        sorted[key] = this.sortObjectByKeys(obj[key]);
      });

    return sorted;
  }
}

// WEBSOCKET REAL-TIME COMMUNICATION

// Notifications Gateway - handles real-time WebSocket connections for live updates

@WebSocketGateway({
  cors: {
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true,
  },
})
export class NotificationsGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger(NotificationsGateway.name);
  private userSockets = new Map<string, Set<string>>();

  constructor(private jwtService: JwtService) {}

  // Handle new WebSocket connections with JWT authentication
  handleConnection(client: AuthenticatedSocket) {
    try {
      const token = client.handshake.auth?.token || 
                   client.handshake.headers?.authorization?.split(' ')[1];

      if (!token) {
        this.logger.warn(`Client ${client.id} connected without token`);
        client.disconnect();
        return;
      }

      const payload = this.jwtService.verify(token);
      const userId = payload?.sub || payload?.userId;
      if (!userId) {
        this.logger.warn(`Client ${client.id} provided token without user id`);
        client.disconnect();
        return;
      }

      client.userId = userId;

      if (!this.userSockets.has(userId)) {
        this.userSockets.set(userId, new Set());
      }
      this.userSockets.get(userId)!.add(client.id);

      void client.join(`user_${userId}`);
      this.logger.log(`Client ${client.id} connected for user ${userId}`);
    } catch (error) {
      this.logger.error(`WebSocket authentication failed for ${client.id}:`, error.message);
      client.disconnect();
    }
  }

  // Handle WebSocket disconnections
  handleDisconnect(client: AuthenticatedSocket) {
    if (client.userId) {
      const userSockets = this.userSockets.get(client.userId);
      if (userSockets) {
        userSockets.delete(client.id);
        if (userSockets.size === 0) {
          this.userSockets.delete(client.userId);
        }
      }
      this.logger.log(`Client ${client.id} disconnected for user ${client.userId}`);
    }
  }

  // Subscribe to specific API updates
  @SubscribeMessage('subscribe:api')
  handleApiSubscription(
    @MessageBody() data: { apiId: string },
    @ConnectedSocket() client: AuthenticatedSocket,
  ) {
    if (client.userId) {
      void client.join(`api_${data.apiId}`);
      this.logger.log(`User ${client.userId} subscribed to API ${data.apiId}`);
    }
  }

  // Unsubscribe from API updates
  @SubscribeMessage('unsubscribe:api')
  handleApiUnsubscription(
    @MessageBody() data: { apiId: string },
    @ConnectedSocket() client: AuthenticatedSocket,
  ) {
    if (client.userId) {
      void client.leave(`api_${data.apiId}`);
      this.logger.log(`User ${client.userId} unsubscribed from API ${data.apiId}`);
    }
  }

  // Subscribe to all user's APIs
  @SubscribeMessage('subscribe:user_apis')
  handleUserApisSubscription(@ConnectedSocket() client: AuthenticatedSocket) {
    if (client.userId) {
      void client.join(`user_apis_${client.userId}`);
      this.logger.log(`User ${client.userId} subscribed to all their APIs`);
    }
  }

  // Real-time notification broadcasting
  sendToUser(userId: string, event: string, data: any) {
    this.server.to(`user_${userId}`).emit(event, data);
  }

  sendToApiSubscribers(apiId: string, event: string, data: any) {
    this.server.to(`api_${apiId}`).emit(event, data);
  }

  sendToAllUserApis(userId: string, event: string, data: any) {
    this.server.to(`user_apis_${userId}`).emit(event, data);
  }

  // Broadcast different types of real-time updates
  broadcastNotification(userId: string, notification: any) {
    this.sendToUser(userId, 'notification:new', notification);
  }

  broadcastAPIUpdate(apiId: string, userId: string, update: any) {
    this.sendToApiSubscribers(apiId, 'api:update', update);
    this.sendToUser(userId, 'api:update', update);
  }

  broadcastAPIChange(apiId: string, userId: string, change: any) {
    this.sendToApiSubscribers(apiId, 'api:change', change);
    this.sendToUser(userId, 'api:change', change);
  }

  broadcastMetricsUpdate(apiId: string, userId: string, metrics: any) {
    this.sendToApiSubscribers(apiId, 'metrics:update', metrics);
    this.sendToUser(userId, 'metrics:update', metrics);
  }
}

// ADVANCED MIDDLEWARE & SECURITY

// Global Exception Filter - comprehensive error handling with logging

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { MongoError } from 'mongodb';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status: number;
    let message: string | object;
    let error: string;

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'object') {
        message = (exceptionResponse as any).message || exceptionResponse;
        error = (exceptionResponse as any).error || exception.name;
      } else {
        message = exceptionResponse;
        error = exception.name;
      }
    } else if (exception instanceof MongoError) {
      status = HttpStatus.BAD_REQUEST;

      switch (exception.code) {
        case 11000: {
          const field = Object.keys((exception as any).keyPattern || {})[0];
          message = `${field} already exists`;
          error = 'Duplicate Entry';
          break;
        }
        case 121: {
          message = 'Document validation failed';
          error = 'Validation Error';
          break;
        }
        default: {
          message = 'Database operation failed';
          error = 'Database Error';
        }
      }
    } else if (exception instanceof Error) {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = exception.message || 'Internal server error';
      error = exception.name || 'Internal Server Error';
    } else {
      status = HttpStatus.INTERNAL_SERVER_ERROR;
      message = 'Internal server error';
      error = 'Unknown Error';
    }

    const logContext = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message,
      error,
      userAgent: request.get('User-Agent'),
      ip: request.ip,
    };

    if (status >= 500) {
      this.logger.error('Internal Server Error', JSON.stringify(logContext, null, 2));
    } else {
      this.logger.warn('Client Error', JSON.stringify(logContext, null, 2));
    }

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message,
      error,
    });
  }
}

// Logging Interceptor - comprehensive request/response logging with security

import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request, Response } from 'express';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest<Request>();
    const response = context.switchToHttp().getResponse<Response>();
    const { method, url, body, query, params } = request;
    const userAgent = request.get('User-Agent') || '';
    const ip = request.ip;

    const now = Date.now();

    const skipLogging = ['/health', '/api/docs', '/favicon.ico'].some((path) =>
      url.includes(path),
    );

    if (skipLogging) {
      return next.handle();
    }

    const requestLog = {
      method,
      url,
      userAgent,
      ip,
      ...(Object.keys(query).length && { query }),
      ...(Object.keys(params).length && { params }),
      ...(method !== 'GET' &&
        body &&
        !this.containsSensitiveData(body) && { body }),
    };

    this.logger.log(`📥 ${method} ${url}`, JSON.stringify(requestLog, null, 2));

    return next.handle().pipe(
      tap({
        next: (responseBody) => {
          const delay = Date.now() - now;
          const responseLog = {
            method,
            url,
            statusCode: response.statusCode,
            delay: `${delay}ms`,
            ...(responseBody &&
              !this.containsSensitiveData(responseBody) && {
                responseSize: JSON.stringify(responseBody).length,
              }),
          };

          this.logger.log(
            `📤 ${method} ${url} - ${response.statusCode}`,
            JSON.stringify(responseLog, null, 2),
          );
        },
        error: (error) => {
          const delay = Date.now() - now;
          this.logger.error(
            `❌ ${method} ${url} - ${error.status || 500} - ${delay}ms`,
            error.message,
          );
        },
      }),
    );
  }

  private containsSensitiveData(obj: any): boolean {
    if (!obj || typeof obj !== 'object') return false;

    const sensitiveFields = [
      'password',
      'token',
      'authorization',
      'secret',
      'key',
      'refresh_token',
      'access_token',
      'refreshToken',
      'accessToken',
    ];

    const objString = JSON.stringify(obj).toLowerCase();
    return sensitiveFields.some((field) => objString.includes(field));
  }
}

// JWT Strategy - advanced token extraction and validation

import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { JwtPayload, ValidatedUser } from 'src/types/jwt.type';
import { ConfigService } from '@nestjs/config';
import { Request } from 'express';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private configService: ConfigService) {
    const jwtSecret =
      configService.get<string>('jwt.secret') ||
      configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error(
        'JWT_SECRET environment variable is not set. Please configure it before starting the application.',
      );
    }

    super({
      jwtFromRequest: ExtractJwt.fromExtractors([
        ExtractJwt.fromAuthHeaderAsBearerToken(),
        (request: Request) => {
          const cookies = request.cookies as Record<string, string> | undefined;
          return cookies?.access_token || null;
        },
      ]),
      secretOrKey: jwtSecret,
    });
  }

  validate(payload: JwtPayload): ValidatedUser {
    const validatedUser: ValidatedUser = {
      userId: payload.sub,
      email: payload.email,
    };
    return validatedUser;
  }
}

// CONFIGURATION MANAGEMENT

// Comprehensive Configuration Schema - production-ready settings

export default (): Record<string, any> => ({
  port: parseInt(process.env.PORT || '3000', 10),

  database: {
    uri: process.env.MONGO_URI || 'mongodb://localhost:27017/api-lens',
    options: {
      serverSelectionTimeoutMS: 30000,
      socketTimeoutMS: 45000,
      connectTimeoutMS: 30000,
      bufferCommands: false,
      maxPoolSize: 15,
      minPoolSize: 2,
      maxIdleTimeMS: 30000,
      waitQueueTimeoutMS: 10000,
      retryWrites: true,
      retryReads: true,
      heartbeatFrequencyMS: 30000,
      compressors: ['zlib'],
    },
  },

  jwt: {
    secret: process.env.JWT_SECRET || 'your-super-secret-jwt-key',
    expiresIn: process.env.JWT_EXPIRES_IN || '1h',
    refreshSecret:
      process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key',
    refreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN || '7d',
  },

  email: {
    service: process.env.EMAIL_SERVICE || 'gmail',
    host: process.env.EMAIL_HOST || 'smtp.gmail.com',
    port: parseInt(process.env.EMAIL_PORT || '587', 10),
    secure: process.env.EMAIL_SECURE === 'true',
    user: process.env.EMAIL_USER || '',
    password: process.env.EMAIL_PASSWORD || '',
    from: process.env.EMAIL_FROM || 'noreply@apilens.com',
  },

  app: {
    name: 'API Lens',
    baseUrl: process.env.APP_BASE_URL || 'http://localhost:3000',
    frontendUrl: process.env.FRONTEND_URL || 'http://localhost:3001',
    environment: process.env.NODE_ENV || 'development',
  },

  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379', 10),
    password: process.env.REDIS_PASSWORD || undefined,
    db: parseInt(process.env.REDIS_DB || '0', 10),
  },

  monitoring: {
    defaultCheckFrequency: process.env.DEFAULT_CHECK_FREQUENCY || '1h',
    maxRetries: parseInt(process.env.MAX_RETRIES || '3', 10),
    requestTimeout: parseInt(process.env.REQUEST_TIMEOUT || '10000', 10),
    batchSize: parseInt(process.env.BATCH_SIZE || '10', 10),
    rateLimitWindow: parseInt(process.env.RATE_LIMIT_WINDOW || '900000', 10),
    rateLimitMax: parseInt(process.env.RATE_LIMIT_MAX || '100', 10),
  },

  notifications: {
    defaultChannels: process.env.DEFAULT_NOTIFICATION_CHANNELS?.split(',') || [
      'in-app',
      'email',
    ],
    webhookTimeout: parseInt(process.env.WEBHOOK_TIMEOUT || '5000', 10),
    emailRetries: parseInt(process.env.EMAIL_RETRIES || '3', 10),
  },

  security: {
    bcryptRounds: parseInt(process.env.BCRYPT_ROUNDS || '12', 10),
    tokenLength: parseInt(process.env.TOKEN_LENGTH || '32', 10),
    maxLoginAttempts: parseInt(process.env.MAX_LOGIN_ATTEMPTS || '5', 10),
    lockoutDuration: parseInt(process.env.LOCKOUT_DURATION || '900000', 10),
  },

  storage: {
    maxSnapshotRetention: parseInt(
      process.env.MAX_SNAPSHOT_RETENTION || '30',
      10,
    ),
    maxChangelogRetention: parseInt(
      process.env.MAX_CHANGELOG_RETENTION || '90',
      10,
    ),
    compressionEnabled: process.env.COMPRESSION_ENABLED === 'true',
  },

  logging: {
    level: process.env.LOG_LEVEL || 'info',
    format: process.env.LOG_FORMAT || 'combined',
    enableFileLogging: process.env.ENABLE_FILE_LOGGING === 'true',
    logDirectory: process.env.LOG_DIRECTORY || './logs',
  },

  features: {
    enableWebhooks: process.env.ENABLE_WEBHOOKS !== 'false',
    enableEmailNotifications:
      process.env.ENABLE_EMAIL_NOTIFICATIONS !== 'false',
    enableAnalytics: process.env.ENABLE_ANALYTICS === 'true',
    enableCaching: process.env.ENABLE_CACHING !== 'false',
    enableRateLimiting: process.env.ENABLE_RATE_LIMITING !== 'false',
  },

  external: {
    swaggerValidatorUrl:
      process.env.SWAGGER_VALIDATOR_URL ||
      'https://validator.swagger.io/validator',
    openApiValidatorEnabled: process.env.OPENAPI_VALIDATOR_ENABLED === 'true',
  },
});

// ADVANCED SCHEDULING & BACKGROUND SERVICES

// Smart Scheduler Service - intelligent background task management

import { Injectable, Logger } from '@nestjs/common';
import { Cron, CronExpression } from '@nestjs/schedule';
import axios from 'axios';
import { ApisService } from '../apis/apis.service';
import { NotificationsService } from '../notifications/notifications.service';
import { NotificationsGateway } from '../../gateways/notifications.gateway';

@Injectable()
export class SmartSchedulerService {
  private readonly logger = new Logger(SmartSchedulerService.name);

  constructor(
    private readonly apisService: ApisService,
    private readonly notificationsService: NotificationsService,
    private readonly notificationsGateway: NotificationsGateway,
  ) {
    void this.initializeHealthStatuses();
  }

  private async initializeHealthStatuses(): Promise<void> {
    try {
      await this.apisService.initializeApiHealthStatuses();
      this.logger.log('Health status initialization completed');
    } catch (error) {
      this.logger.error(
        `Failed to initialize health statuses: ${error.message}`,
      );
    }
  }

  // Check APIs every 5 minutes for changes
  @Cron('*/5 * * * *')
  async handleApiChecking() {
    this.logger.log('🔍 Starting scheduled API checking...');
    
    try {
      const apisToCheck = await this.apisService.getApisToCheck();
      
      if (apisToCheck.length === 0) {
        this.logger.log('No APIs require checking at this time');
        return;
      }

      this.logger.log(`Found ${apisToCheck.length} APIs to check`);

      for (const api of apisToCheck) {
        await this.checkSingleApi(api._id.toString());
        await this.delay(1000); // Rate limiting
      }

      this.logger.log(`✅ Completed checking ${apisToCheck.length} APIs`);
    } catch (error) {
      this.logger.error(`API checking failed: ${error.message}`);
    }
  }

  private async checkSingleApi(apiId: string): Promise<void> {
    try {
      const result = await this.apisService.checkApiForChanges(apiId);
      
      if (result.hasChanges && result.changes) {
        const changeType = this.determineChangeType(result.changes);
        
        this.logger.log(
          `🔄 Changes detected in API ${apiId}: ${result.changes.length} changes (${changeType})`
        );

        // Emit real-time notification
        this.notificationsGateway.emitApiCheckComplete({
          apiId,
          hasChanges: true,
          changeCount: result.changes.length,
          changeType,
          newVersion: result.newVersion,
          timestamp: new Date().toISOString(),
        });
      }
    } catch (error) {
      this.logger.error(`Failed to check API ${apiId}: ${error.message}`);
    }
  }

  private determineChangeType(changes: any[]): string {
    const hasBreaking = changes.some(change => 
      change.changeType === 'breaking' || change.severity === 'critical'
    );
    return hasBreaking ? 'breaking' : 'non-breaking';
  }

  // Perform health checks every hour
  @Cron(CronExpression.EVERY_HOUR)
  private async performHealthChecks() {
    this.logger.log('🏥 Starting health checks...');
    
    try {
      await this.apisService.updateApiHealthScores();
      this.logger.log('Health checks completed successfully');
    } catch (error) {
      this.logger.error(`Health checks failed: ${error.message}`);
    }
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async triggerImmediateCheck(): Promise<{ message: string; checked: number }> {
    this.logger.log('Manual trigger: checking all active APIs immediately');

    const apisToCheck = await this.apisService.getApisToCheck();

    const promises = apisToCheck.map((api) =>
      this.checkSingleApi((api._id as any).toString()),
    );
    await Promise.allSettled(promises);

    return {
      message: 'Immediate check completed',
      checked: apisToCheck.length,
    };
  }
}
}

// DATA TRANSFER OBJECTS (DTOs)

// CreateApiDto - API registration validation

import { IsString, IsOptional, IsArray, IsIn } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateApiDto {
  @ApiProperty({
    description: 'Name of the API to monitor',
    example: 'My REST API',
  })
  @IsString()
  apiName: string;

  @ApiProperty({
    description: 'URL to the OpenAPI specification (JSON or YAML)',
    example: 'https://api.example.com/openapi.json',
    format: 'url',
  })
  @IsString()
  openApiUrl: string;

  @ApiProperty({
    description: 'Type of API specification',
    example: 'openapi',
    default: 'openapi',
    required: false,
  })
  @IsOptional()
  @IsString()
  type: string = 'openapi';

  @ApiProperty({
    description: 'How frequently to check for changes',
    example: '1h',
    enum: ['30s', '1m', '5m', '15m', '1h', '6h', '1d'],
    default: '1h',
    required: false,
  })
  @IsOptional()
  @IsString()
  @IsIn(['30s', '1m', '5m', '15m', '1h', '6h', '1d'])
  checkFrequency: string = '1h';

  @ApiProperty({
    description: 'Tags to categorize the API',
    example: ['production', 'v1', 'public'],
    type: [String],
    required: false,
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  @ApiProperty({
    description: 'Description of the API',
    example: 'Main production API for user management',
    required: false,
  })
  @IsOptional()
  @IsString()
  description?: string;
}

// End of API Backend Code

// APILens Frontend Client Code

// Next.js App Router Layout

import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';
import { Providers } from '@/components/Providers';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'APILens - API Monitoring & Change Detection',
  description:
    'Advanced API monitoring, change detection, and documentation platform',
  keywords:
    'API monitoring, change detection, API documentation, OpenAPI, REST API',
  authors: [{ name: 'APILens Team' }],
  openGraph: {
    title: 'APILens - API Monitoring & Change Detection',
    description:
      'Advanced API monitoring, change detection, and documentation platform',
    type: 'website',
    locale: 'en_US',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'APILens - API Monitoring & Change Detection',
    description:
      'Advanced API monitoring, change detection, and documentation platform',
  },
  robots: 'index, follow',
};

export const viewport: Viewport = {
  width: 'device-width',
  initialScale: 1,
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className="h-full">
      <body
        className={`${inter.className} h-full bg-gray-50 dark:bg-gray-900 antialiased`}
      >
        <Providers>
          <main className="min-h-full">{children}</main>
          <Toaster
            position="top-right"
            toastOptions={{
              duration: 4000,
              style: {
                background: '#363636',
                color: '#fff',
              },
              success: {
                duration: 3000,
                iconTheme: {
                  primary: '#10b981',
                  secondary: '#fff',
                },
              },
              error: {
                duration: 5000,
                iconTheme: {
                  primary: '#ef4444',
                  secondary: '#fff',
                },
              },
            }}
          />
        </Providers>
      </body>
    </html>
  );
}

// Application Providers

'use client';

import React from 'react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { WebSocketProvider } from '@/providers/WebSocketProvider';
import { RealtimeProvider } from '@/providers/RealtimeProvider';
import { Toaster } from 'react-hot-toast';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes
      retry: (failureCount, error: any) => {
        if (
          error?.response?.status >= 400 &&
          error?.response?.status < 500 &&
          error?.response?.status !== 408
        ) {
          return false;
        }
        return failureCount < 3;
      },
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
    },
    mutations: {
      retry: (failureCount, error: any) => {
        if (error?.response?.status >= 400 && error?.response?.status < 500) {
          return false;
        }
        return failureCount < 1;
      },
    },
  },
});

interface ProvidersProps {
  children: React.ReactNode;
}

export function Providers({ children }: ProvidersProps) {
  return (
    <QueryClientProvider client={queryClient}>
      <WebSocketProvider>
        <RealtimeProvider>
          {children}
        </RealtimeProvider>
      </WebSocketProvider>
      {process.env.NODE_ENV === 'development' && (
        <ReactQueryDevtools initialIsOpen={false} />
      )}
    </QueryClientProvider>
  );
}

// AUTHENTICATION PAGES

// Login Page - user authentication form
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { useAuthHooks } from '@/hooks/useAuth';
import RouteGuard from '@/components/RouteGuard';
import { Activity, Eye, EyeOff, Loader2, Mail, Lock, AlertCircle } from 'lucide-react';

const LoginPage = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});

  const { login, isLoginPending } = useAuthHooks();

  const validateForm = () => {
    const newErrors: Record<string, string> = {};

    if (!email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      newErrors.email = 'Please enter a valid email address';
    }

    if (!password.trim()) {
      newErrors.password = 'Password is required';
    } else if (password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!validateForm()) return;
    login({ email, password });
  };

  return (
    <RouteGuard requireAuth={false} redirectTo="/dashboard">
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-xl shadow-lg w-full max-w-md">
          <div className="text-center pt-8 pb-6 px-8">
            <div className="w-16 h-16 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl mx-auto mb-4 flex items-center justify-center shadow-lg">
              <Activity className="text-white w-8 h-8" />
            </div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">APILens</h1>
            <p className="text-gray-600">Monitor your APIs and track changes</p>
          </div>

          <div className="px-8 pb-8">
            <form onSubmit={handleSubmit} className="space-y-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Email address
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Mail className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    placeholder="Enter your email"
                    className={`w-full pl-10 pr-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors ${
                      errors.email ? 'border-red-500' : 'border-gray-300'
                    }`}
                    disabled={isLoginPending}
                  />
                </div>
                {errors.email && (
                  <div className="mt-1 flex items-center text-sm text-red-600">
                    <AlertCircle className="w-4 h-4 mr-1" />
                    {errors.email}
                  </div>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Password
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Lock className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    type={showPassword ? 'text' : 'password'}
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    placeholder="Enter your password"
                    className={`w-full pl-10 pr-12 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors ${
                      errors.password ? 'border-red-500' : 'border-gray-300'
                    }`}
                    disabled={isLoginPending}
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute inset-y-0 right-0 pr-3 flex items-center"
                    disabled={isLoginPending}
                  >
                    {showPassword ? (
                      <EyeOff className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                    ) : (
                      <Eye className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                    )}
                  </button>
                </div>
                {errors.password && (
                  <div className="mt-1 flex items-center text-sm text-red-600">
                    <AlertCircle className="w-4 h-4 mr-1" />
                    {errors.password}
                  </div>
                )}
              </div>

              <button
                type="submit"
                disabled={isLoginPending}
                className="w-full flex items-center justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
              >
                {isLoginPending ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Signing in...
                  </>
                ) : (
                  'Sign in'
                )}
              </button>

              <div className="text-center">
                <Link
                  href="/register"
                  className="text-blue-600 hover:text-blue-500 font-medium"
                >
                  Create a new account
                </Link>
              </div>
            </form>
          </div>
        </div>
      </div>
    </RouteGuard>
  );
};

// Register Page - user registration form
'use client';

import React, { useState } from 'react';
import Link from 'next/link';
import { useAuthHooks } from '@/hooks/useAuth';
import RouteGuard from '@/components/RouteGuard';
import { Activity, Eye, EyeOff, Loader2, Mail, Lock, AlertCircle } from 'lucide-react';

const RegisterPage = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  const { register, isRegisterPending } = useAuthHooks();

  const validateForm = () => {
    const newErrors: Record<string, string> = {};
    
    if (!email.trim()) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(email)) {
      newErrors.email = 'Please enter a valid email address';
    }
    
    if (!password.trim()) {
      newErrors.password = 'Password is required';
    } else if (password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }
    
    if (!confirmPassword.trim()) {
      newErrors.confirmPassword = 'Please confirm your password';
    } else if (password !== confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!validateForm()) return;
    register({ email, password, role: 'user' });
  };

  return (
    <RouteGuard requireAuth={false} redirectTo="/dashboard">
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-xl shadow-lg w-full max-w-md">
          <div className="text-center pt-8 pb-6 px-8">
            <div className="w-16 h-16 bg-gradient-to-r from-blue-600 to-indigo-600 rounded-xl mx-auto mb-4 flex items-center justify-center shadow-lg">
              <Activity className="text-white w-8 h-8" />
            </div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Create Account</h1>
            <p className="text-gray-600">Start monitoring your APIs today</p>
          </div>

          <div className="px-8 pb-8">
            <form onSubmit={handleSubmit} className="space-y-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Email address
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Mail className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    type="email"
                    value={email}
                    onChange={(e) => setEmail(e.target.value)}
                    placeholder="Enter your email"
                    className={`w-full pl-10 pr-4 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors ${
                      errors.email ? 'border-red-500' : 'border-gray-300'
                    }`}
                    disabled={isRegisterPending}
                  />
                </div>
                {errors.email && (
                  <div className="mt-1 flex items-center text-sm text-red-600">
                    <AlertCircle className="w-4 h-4 mr-1" />
                    {errors.email}
                  </div>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Password
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Lock className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    type={showPassword ? 'text' : 'password'}
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    placeholder="Create a password"
                    className={`w-full pl-10 pr-12 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors ${
                      errors.password ? 'border-red-500' : 'border-gray-300'
                    }`}
                    disabled={isRegisterPending}
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="absolute inset-y-0 right-0 pr-3 flex items-center"
                    disabled={isRegisterPending}
                  >
                    {showPassword ? (
                      <EyeOff className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                    ) : (
                      <Eye className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                    )}
                  </button>
                </div>
                {errors.password && (
                  <div className="mt-1 flex items-center text-sm text-red-600">
                    <AlertCircle className="w-4 h-4 mr-1" />
                    {errors.password}
                  </div>
                )}
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Confirm Password
                </label>
                <div className="relative">
                  <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                    <Lock className="h-5 w-5 text-gray-400" />
                  </div>
                  <input
                    type={showConfirmPassword ? 'text' : 'password'}
                    value={confirmPassword}
                    onChange={(e) => setConfirmPassword(e.target.value)}
                    placeholder="Confirm your password"
                    className={`w-full pl-10 pr-12 py-3 border rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent transition-colors ${
                      errors.confirmPassword ? 'border-red-500' : 'border-gray-300'
                    }`}
                    disabled={isRegisterPending}
                  />
                  <button
                    type="button"
                    onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                    className="absolute inset-y-0 right-0 pr-3 flex items-center"
                    disabled={isRegisterPending}
                  >
                    {showConfirmPassword ? (
                      <EyeOff className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                    ) : (
                      <Eye className="h-5 w-5 text-gray-400 hover:text-gray-600" />
                    )}
                  </button>
                </div>
                {errors.confirmPassword && (
                  <div className="mt-1 flex items-center text-sm text-red-600">
                    <AlertCircle className="w-4 h-4 mr-1" />
                    {errors.confirmPassword}
                  </div>
                )}
              </div>

              <button
                type="submit"
                disabled={isRegisterPending}
                className="w-full flex items-center justify-center py-3 px-4 border border-transparent rounded-lg shadow-sm text-sm font-medium text-white bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-200"
              >
                {isRegisterPending ? (
                  <>
                    <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    Creating account...
                  </>
                ) : (
                  'Create account'
                )}
              </button>

              <div className="text-center">
                <Link
                  href="/login"
                  className="text-blue-600 hover:text-blue-500 font-medium"
                >
                  Sign in to your account
                </Link>
              </div>
            </form>
          </div>
        </div>
      </div>
    </RouteGuard>
  );
};

// CHANGELOG COMPONENTS

// ChangelogTimeline - timeline visualization for API changes
'use client';

import React from 'react';
import { formatDistanceToNow } from 'date-fns';
import { 
  GitCommit, 
  GitBranch, 
  AlertTriangle, 
  CheckCircle, 
  XCircle,
  Plus,
  Minus,
  Edit3
} from 'lucide-react';

interface Change {
  id: string;
  type: 'breaking' | 'addition' | 'modification' | 'deprecation';
  severity: 'critical' | 'major' | 'minor';
  title: string;
  description: string;
  timestamp: Date;
  apiName: string;
  version?: string;
  details?: {
    path?: string;
    method?: string;
    field?: string;
    oldValue?: any;
    newValue?: any;
  };
}

interface ChangelogTimelineProps {
  changes: Change[];
  onChangeClick?: (change: Change) => void;
}

const ChangelogTimeline: React.FC<ChangelogTimelineProps> = ({
  changes,
  onChangeClick
}) => {
  const getChangeIcon = (type: Change['type']) => {
    switch (type) {
      case 'breaking':
        return <XCircle className="w-4 h-4 text-red-500" />;
      case 'addition':
        return <Plus className="w-4 h-4 text-green-500" />;
      case 'modification':
        return <Edit3 className="w-4 h-4 text-blue-500" />;
      case 'deprecation':
        return <Minus className="w-4 h-4 text-orange-500" />;
      default:
        return <GitCommit className="w-4 h-4 text-gray-500" />;
    }
  };

  const getSeverityColor = (severity: Change['severity']) => {
    switch (severity) {
      case 'critical':
        return 'bg-red-100 text-red-800 border-red-200';
      case 'major':
        return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'minor':
        return 'bg-blue-100 text-blue-800 border-blue-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  const getTypeColor = (type: Change['type']) => {
    switch (type) {
      case 'breaking':
        return 'bg-red-50 border-red-200';
      case 'addition':
        return 'bg-green-50 border-green-200';
      case 'modification':
        return 'bg-blue-50 border-blue-200';
      case 'deprecation':
        return 'bg-orange-50 border-orange-200';
      default:
        return 'bg-gray-50 border-gray-200';
    }
  };

  if (changes.length === 0) {
    return (
      <div className="text-center py-12">
        <GitBranch className="w-12 h-12 text-gray-400 mx-auto mb-4" />
        <h3 className="text-lg font-medium text-gray-900 mb-2">No changes yet</h3>
        <p className="text-gray-500">API changes will appear here when detected</p>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {changes.map((change, index) => (
        <div
          key={change.id}
          className={`relative pl-8 pb-6 ${
            index !== changes.length - 1 ? 'border-l-2 border-gray-200' : ''
          }`}
        >
          <div className="absolute -left-2 top-0 w-4 h-4 bg-white border-2 border-gray-300 rounded-full flex items-center justify-center">
            {getChangeIcon(change.type)}
          </div>
          
          <div
            className={`bg-white rounded-lg border-2 p-4 shadow-sm cursor-pointer transition-all duration-200 hover:shadow-md ${getTypeColor(
              change.type
            )}`}
            onClick={() => onChangeClick?.(change)}
          >
            <div className="flex items-start justify-between mb-2">
              <div className="flex items-center space-x-2">
                <span
                  className={`inline-flex px-2 py-1 text-xs font-medium rounded-full border ${getSeverityColor(
                    change.severity
                  )}`}
                >
                  {change.severity}
                </span>
                <span className="text-xs text-gray-500 capitalize">
                  {change.type}
                </span>
                {change.version && (
                  <span className="text-xs bg-gray-100 text-gray-600 px-2 py-1 rounded">
                    v{change.version}
                  </span>
                )}
              </div>
              <time className="text-xs text-gray-500">
                {formatDistanceToNow(change.timestamp, { addSuffix: true })}
              </time>
            </div>

            <div className="mb-2">
              <h4 className="text-sm font-medium text-gray-900 mb-1">
                {change.title}
              </h4>
              <p className="text-sm text-gray-600 mb-2">{change.description}</p>
              <div className="text-xs text-gray-500">
                <span className="font-medium">{change.apiName}</span>
                {change.details?.path && (
                  <>
                    <span className="mx-1">•</span>
                    <span className="font-mono">{change.details.path}</span>
                  </>
                )}
                {change.details?.method && (
                  <>
                    <span className="mx-1">•</span>
                    <span className="font-mono text-blue-600">
                      {change.details.method}
                    </span>
                  </>
                )}
              </div>
            </div>

            {change.details?.field && (
              <div className="text-xs bg-gray-50 rounded p-2 border">
                <div className="font-medium text-gray-700 mb-1">
                  Field: <code className="text-blue-600">{change.details.field}</code>
                </div>
                {change.details.oldValue !== undefined && (
                  <div className="text-red-600">
                    - {JSON.stringify(change.details.oldValue)}
                  </div>
                )}
                {change.details.newValue !== undefined && (
                  <div className="text-green-600">
                    + {JSON.stringify(change.details.newValue)}
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      ))}
    </div>
  );
};

// DetailedChangeView - change information modal
'use client';

import React from 'react';
import { 
  X, 
  Calendar, 
  Tag, 
  AlertTriangle, 
  Info,
  Code,
  FileText,
  GitCommit
} from 'lucide-react';

interface DetailedChangeViewProps {
  change: Change | null;
  isOpen: boolean;
  onClose: () => void;
}

const DetailedChangeView: React.FC<DetailedChangeViewProps> = ({
  change,
  isOpen,
  onClose
}) => {
  if (!isOpen || !change) return null;

  const getSeverityIcon = (severity: Change['severity']) => {
    switch (severity) {
      case 'critical':
        return <AlertTriangle className="w-5 h-5 text-red-500" />;
      case 'major':
        return <Info className="w-5 h-5 text-orange-500" />;
      case 'minor':
        return <Info className="w-5 h-5 text-blue-500" />;
      default:
        return <Info className="w-5 h-5 text-gray-500" />;
    }
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
      <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[90vh] overflow-hidden">
        <div className="flex items-center justify-between p-6 border-b">
          <div className="flex items-center space-x-3">
            {getSeverityIcon(change.severity)}
            <h2 className="text-xl font-semibold text-gray-900">
              Change Details
            </h2>
          </div>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 transition-colors"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        <div className="p-6 overflow-y-auto max-h-[calc(90vh-120px)]">
          <div className="space-y-6">
            <div>
              <h3 className="text-lg font-medium text-gray-900 mb-2">
                {change.title}
              </h3>
              <p className="text-gray-600">{change.description}</p>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-3">
                <div className="flex items-center space-x-2">
                  <Tag className="w-4 h-4 text-gray-400" />
                  <span className="text-sm font-medium text-gray-700">Type</span>
                  <span className="text-sm bg-blue-100 text-blue-800 px-2 py-1 rounded capitalize">
                    {change.type}
                  </span>
                </div>
                
                <div className="flex items-center space-x-2">
                  <AlertTriangle className="w-4 h-4 text-gray-400" />
                  <span className="text-sm font-medium text-gray-700">Severity</span>
                  <span className={`text-sm px-2 py-1 rounded capitalize ${
                    change.severity === 'critical' ? 'bg-red-100 text-red-800' :
                    change.severity === 'major' ? 'bg-orange-100 text-orange-800' :
                    'bg-blue-100 text-blue-800'
                  }`}>
                    {change.severity}
                  </span>
                </div>

                <div className="flex items-center space-x-2">
                  <Calendar className="w-4 h-4 text-gray-400" />
                  <span className="text-sm font-medium text-gray-700">When</span>
                  <span className="text-sm text-gray-600">
                    {change.timestamp.toLocaleString()}
                  </span>
                </div>
              </div>

              <div className="space-y-3">
                <div className="flex items-center space-x-2">
                  <FileText className="w-4 h-4 text-gray-400" />
                  <span className="text-sm font-medium text-gray-700">API</span>
                  <span className="text-sm text-gray-600">{change.apiName}</span>
                </div>

                {change.version && (
                  <div className="flex items-center space-x-2">
                    <GitCommit className="w-4 h-4 text-gray-400" />
                    <span className="text-sm font-medium text-gray-700">Version</span>
                    <span className="text-sm bg-gray-100 text-gray-600 px-2 py-1 rounded">
                      v{change.version}
                    </span>
                  </div>
                )}

                {change.details?.path && (
                  <div className="flex items-start space-x-2">
                    <Code className="w-4 h-4 text-gray-400 mt-0.5" />
                    <div>
                      <span className="text-sm font-medium text-gray-700 block">Path</span>
                      <code className="text-sm bg-gray-100 text-gray-800 px-2 py-1 rounded">
                        {change.details.path}
                      </code>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {change.details && (
              <div className="border-t pt-6">
                <h4 className="text-md font-medium text-gray-900 mb-4">
                  Technical Details
                </h4>
                
                {change.details.method && (
                  <div className="mb-4">
                    <span className="text-sm font-medium text-gray-700 block mb-1">
                      HTTP Method
                    </span>
                    <span className="inline-block bg-blue-100 text-blue-800 text-sm px-2 py-1 rounded font-mono">
                      {change.details.method}
                    </span>
                  </div>
                )}

                {change.details.field && (
                  <div className="mb-4">
                    <span className="text-sm font-medium text-gray-700 block mb-1">
                      Affected Field
                    </span>
                    <code className="text-sm bg-gray-100 text-gray-800 px-2 py-1 rounded">
                      {change.details.field}
                    </code>
                  </div>
                )}

                {(change.details.oldValue !== undefined || change.details.newValue !== undefined) && (
                  <div className="space-y-3">
                    <span className="text-sm font-medium text-gray-700 block">
                      Value Changes
                    </span>
                    
                    <div className="bg-gray-50 rounded-lg p-4 space-y-2">
                      {change.details.oldValue !== undefined && (
                        <div>
                          <span className="text-xs text-red-600 font-medium block mb-1">
                            - OLD VALUE
                          </span>
                          <pre className="text-sm bg-red-50 text-red-800 p-2 rounded border border-red-200 overflow-x-auto">
                            {JSON.stringify(change.details.oldValue, null, 2)}
                          </pre>
                        </div>
                      )}
                      
                      {change.details.newValue !== undefined && (
                        <div>
                          <span className="text-xs text-green-600 font-medium block mb-1">
                            + NEW VALUE
                          </span>
                          <pre className="text-sm bg-green-50 text-green-800 p-2 rounded border border-green-200 overflow-x-auto">
                            {JSON.stringify(change.details.newValue, null, 2)}
                          </pre>
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>

        <div className="p-6 border-t bg-gray-50">
          <div className="flex justify-end">
            <button
              onClick={onClose}
              className="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

// DASHBOARD COMPONENTS

// Main Dashboard Page

'use client';

import React, { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Layout from '@/components/layout/Layout';
import RouteGuard from '@/components/RouteGuard';
import { useDashboardOverview, useDashboardStats } from '@/hooks/useDashboard';
import { useRealtime } from '@/hooks/useRealtime';
import { formatDistanceToNow } from 'date-fns';
import {
  Activity,
  AlertTriangle,
  CheckCircle,
  Clock,
  TrendingUp,
  TrendingDown,
  BarChart3,
  Bell,
  Plus,
  RefreshCw,
  Eye,
} from 'lucide-react';

const DashboardPage = () => {
  const router = useRouter();
  const [refreshing, setRefreshing] = useState(false);
  
  const { 
    data: overview, 
    isLoading: overviewLoading, 
    refetch: refetchOverview 
  } = useDashboardOverview();
  
  const { 
    data: stats, 
    isLoading: statsLoading, 
    refetch: refetchStats 
  } = useDashboardStats();

  // Real-time updates integration
  const { isConnected } = useRealtime();

  const handleRefresh = async () => {
    setRefreshing(true);
    await Promise.all([refetchOverview(), refetchStats()]);
    setRefreshing(false);
  };

  if (overviewLoading || statsLoading) {
    return (
      <RouteGuard requireAuth={true}>
        <Layout>
          <div className="flex items-center justify-center min-h-96">
            <div className="flex items-center space-x-3">
              <RefreshCw className="w-6 h-6 animate-spin text-blue-600" />
              <span className="text-lg text-gray-600">Loading dashboard...</span>
            </div>
          </div>
        </Layout>
      </RouteGuard>
    );
  }

  const {
    totalApis = 0,
    activeApis = 0,
    healthyApis = 0,
    unhealthyApis = 0,
    totalChanges = 0,
    recentChanges = 0,
    criticalIssues = 0,
  } = stats || {};

  return (
    <RouteGuard requireAuth={true}>
      <Layout>
        <div className="space-y-6">
          {/* Header Section */}
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-900">Dashboard</h1>
              <p className="mt-1 text-sm text-gray-500">
                Monitor your APIs and track changes in real-time
              </p>
            </div>
            <div className="mt-4 flex space-x-3 sm:mt-0">
              <button
                onClick={handleRefresh}
                disabled={refreshing}
                className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <RefreshCw className={`w-4 h-4 mr-2 ${refreshing ? 'animate-spin' : ''}`} />
                Refresh
              </button>
              <Link
                href="/add-api"
                className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
              >
                <Plus className="w-4 h-4 mr-2" />
                Add API
              </Link>
            </div>
          </div>

          {/* Real-time Connection Status */}
          <div className="flex items-center space-x-2">
            <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
            <span className="text-sm text-gray-600">
              {isConnected ? 'Connected' : 'Disconnected'} - Real-time updates
            </span>
          </div>

          {/* Stats Overview Grid */}
          <div className="grid grid-cols-1 gap-5 sm:grid-cols-2 lg:grid-cols-4">
            <StatCard
              title="Total APIs"
              value={totalApis}
              icon={<Activity className="w-6 h-6 text-blue-600" />}
              bgColor="bg-blue-100"
              href="/apis"
            />
            <StatCard
              title="Active APIs"
              value={activeApis}
              subtitle={`${totalApis - activeApis} inactive`}
              icon={<CheckCircle className="w-6 h-6 text-green-600" />}
              bgColor="bg-green-100"
              href="/apis?filter=active"
            />
            <StatCard
              title="Health Issues"
              value={unhealthyApis + criticalIssues}
              subtitle={unhealthyApis > 0 ? `${unhealthyApis} unhealthy` : 'All healthy'}
              icon={<AlertTriangle className="w-6 h-6 text-red-600" />}
              bgColor="bg-red-100"
              href="/issues"
              isAlert={unhealthyApis > 0 || criticalIssues > 0}
            />
            <StatCard
              title="Recent Changes"
              value={recentChanges}
              subtitle={`${totalChanges} total`}
              icon={<TrendingUp className="w-6 h-6 text-yellow-600" />}
              bgColor="bg-yellow-100"
              href="/changes"
            />
          </div>

          {/* Main Content Grid */}
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Recent Activity */}
            <div className="lg:col-span-2">
              <RecentActivityCard activities={overview?.recentActivity || []} />
            </div>

            {/* API Health Summary */}
            <div>
              <ApiHealthSummaryCard apis={overview?.apiHealthSummary || []} />
            </div>
          </div>

          {/* Critical Alerts */}
          {overview?.criticalAlerts && overview.criticalAlerts.length > 0 && (
            <CriticalAlertsCard alerts={overview.criticalAlerts} />
          )}

          {/* Quick Actions */}
          <QuickActionsCard />
        </div>
      </Layout>
    </RouteGuard>
  );
};

// Stat Card Component - reusable metric display card
const StatCard = ({ 
  title, 
  value, 
  subtitle, 
  icon, 
  bgColor, 
  href, 
  isAlert = false 
}: {
  title: string;
  value: number;
  subtitle?: string;
  icon: React.ReactNode;
  bgColor: string;
  href?: string;
  isAlert?: boolean;
}) => {
  const content = (
    <div className={`relative overflow-hidden rounded-lg bg-white px-4 py-5 shadow ${isAlert ? 'ring-2 ring-red-200' : ''}`}>
      <dt>
        <div className={`absolute rounded-md p-3 ${bgColor}`}>
          {icon}
        </div>
        <p className="ml-16 truncate text-sm font-medium text-gray-500">{title}</p>
      </dt>
      <dd className="ml-16 flex items-baseline">
        <p className="text-2xl font-semibold text-gray-900">{value}</p>
        {subtitle && (
          <p className="ml-2 text-sm text-gray-500">{subtitle}</p>
        )}
      </dd>
      {isAlert && value > 0 && (
        <div className="absolute top-2 right-2">
          <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
        </div>
      )}
    </div>
  );

  return href ? (
    <Link href={href} className="block hover:scale-105 transition-transform">
      {content}
    </Link>
  ) : content;
};

export default DashboardPage;

// REAL-TIME COMMUNICATION

// WebSocket Provider

'use client';

import React, { createContext, useContext, useCallback, useRef, useState, useEffect } from 'react';
import { io, Socket } from 'socket.io-client';
import { toast } from 'react-hot-toast';
import { useAuth } from '@/store/auth';
import logger from '@/utils/logger';

interface WebSocketContextType {
  socket: Socket | null;
  isConnected: boolean;
  isConnecting: boolean;
  connectionError: string | null;
  subscribe: (event: string, callback: (data: any) => void) => () => void;
  emit: (event: string, data?: any) => void;
  connect: () => void;
  disconnect: () => void;
}

const WebSocketContext = createContext<WebSocketContextType | undefined>(undefined);

interface WebSocketProviderProps {
  children: React.ReactNode;
  url: string;
  maxReconnectAttempts?: number;
  reconnectDelay?: number;
}

export function WebSocketProvider({ 
  children, 
  url, 
  maxReconnectAttempts = 5,
  reconnectDelay = 3000 
}: WebSocketProviderProps) {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionError, setConnectionError] = useState<string | null>(null);
  const [connectionAttempts, setConnectionAttempts] = useState(0);

  const { user } = useAuth();
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);
  const subscribersRef = useRef<Map<string, Set<(data: any) => void>>>(new Map());

  // Connect to WebSocket server
  const connect = useCallback(() => {
    if (socket?.connected || isConnecting) return;

    setIsConnecting(true);
    setConnectionError(null);

    try {
      const newSocket = io(url, {
        auth: {
          token: user?.api_key,
          userId: user?._id,
        },
        transports: ['websocket', 'polling'],
        timeout: 20000,
        reconnection: false, // Handle reconnection manually
      });

      // Connection successful
      newSocket.on('connect', () => {
        logger.log('WebSocket connected');
        setIsConnected(true);
        setIsConnecting(false);
        setConnectionError(null);
        setConnectionAttempts(0);

        if (reconnectTimeoutRef.current) {
          clearTimeout(reconnectTimeoutRef.current);
        }

        // Re-subscribe to all events
        subscribersRef.current.forEach((callbacks, event) => {
          callbacks.forEach(callback => {
            newSocket.on(event, callback);
          });
        });

        toast.success('Real-time connection established', {
          duration: 2000,
          position: 'bottom-right',
        });
      });

      // Connection failed
      newSocket.on('connect_error', (error) => {
        logger.error('WebSocket connection error:', error);
        setIsConnected(false);
        setIsConnecting(false);
        setConnectionError(error.message);

        if (connectionAttempts < maxReconnectAttempts) {
          scheduleReconnect();
        } else {
          toast.error('Failed to establish real-time connection', {
            duration: 5000,
            position: 'bottom-right',
          });
        }
      });

      newSocket.on('disconnect', (reason) => {
        logger.log('WebSocket disconnected:', reason);
        setIsConnected(false);
        setConnectionError(null);

        if (reason === 'io server disconnect') {
          scheduleReconnect();
        }
      });

      newSocket.on('auth_error', (error) => {
        logger.error('WebSocket auth error:', error);
        setConnectionError('Authentication failed');
        setIsConnected(false);
        setIsConnecting(false);

        toast.error('Authentication failed for real-time updates', {
          duration: 5000,
          position: 'bottom-right',
        });
      });

      // Rate limiting
      newSocket.on('rate_limit', (data) => {
        logger.warn('WebSocket rate limit:', data);
        toast.error('Too many requests. Please slow down.', {
          duration: 3000,
          position: 'bottom-right',
        });
      });

      setSocket(newSocket);
    } catch (error) {
      logger.error('Failed to create WebSocket connection:', error);
      setIsConnecting(false);
      setConnectionError('Failed to initialize connection');
    }
  }, [url, user?.api_key, user?._id, connectionAttempts, maxReconnectAttempts]);

  const scheduleReconnect = useCallback(() => {
    setConnectionAttempts(prev => prev + 1);
    
    reconnectTimeoutRef.current = setTimeout(() => {
      logger.log(`Attempting to reconnect... (${connectionAttempts + 1}/${maxReconnectAttempts})`);
      connect();
    }, reconnectDelay);
  }, [connect, connectionAttempts, maxReconnectAttempts, reconnectDelay]);

  const disconnect = useCallback(() => {
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }
    
    if (socket) {
      socket.disconnect();
      setSocket(null);
    }
    
    setIsConnected(false);
    setIsConnecting(false);
    setConnectionError(null);
    setConnectionAttempts(0);
  }, [socket]);

  const subscribe = useCallback((event: string, callback: (data: any) => void) => {
    if (!subscribersRef.current.has(event)) {
      subscribersRef.current.set(event, new Set());
    }
    subscribersRef.current.get(event)!.add(callback);

    if (socket?.connected) {
      socket.on(event, callback);
    }
    return () => {
      subscribersRef.current.get(event)?.delete(callback);
      if (socket) {
        socket.off(event, callback);
      }
    };
  }, [socket]);

  const emit = useCallback((event: string, data?: any) => {
    if (socket?.connected) {
      socket.emit(event, data);
    } else {
      logger.warn(`Cannot emit ${event}: WebSocket not connected`);
    }
  }, [socket]);
  useEffect(() => {
    if (user?.api_key && !socket && !isConnecting) {
      connect();
    }
  }, [user?.api_key, socket, isConnecting, connect]);
  useEffect(() => {
    return () => {
      disconnect();
    };
  }, [disconnect]);

  const value: WebSocketContextType = {
    socket,
    isConnected,
    isConnecting,
    connectionError,
    subscribe,
    emit,
    connect,
    disconnect,
  };

  return (
    <WebSocketContext.Provider value={value}>
      {children}
    </WebSocketContext.Provider>
  );
}

export function useWebSocket() {
  const context = useContext(WebSocketContext);
  if (context === undefined) {
    throw new Error('useWebSocket must be used within a WebSocketProvider');
  }
  return context;
}

// REAL-TIME HOOKS & PROVIDERS

// Real-time Updates Hook

'use client';

import { useCallback, useEffect } from 'react';
import { useQueryClient } from '@tanstack/react-query';
import { toast } from 'react-hot-toast';
import { useWebSocket } from '@/providers/WebSocketProvider';
import { useAuth } from '@/store/auth';
import { apiQueryKeys } from '@/hooks/useApis';
import { dashboardQueryKeys } from '@/hooks/useDashboard';
import { notificationQueryKeys } from '@/hooks/useNotifications';
import logger from '@/utils/logger';
interface SocketEvents {
  'api:change': (data: {
    apiId: string;
    apiName: string;
    changeType: 'breaking' | 'non-breaking' | 'deprecation' | 'addition';
    severity: 'low' | 'medium' | 'high' | 'critical';
    changeCount: number;
    newVersion?: string;
    timestamp: string;
  }) => void;
  
  'api:health': (data: {
    apiId: string;
    apiName: string;
    status: 'healthy' | 'unhealthy' | 'checking' | 'error';
    previousStatus?: string;
    timestamp: string;
  }) => void;
  
  'notification': (data: {
    id: string;
    type: 'api_change' | 'api_error' | 'api_recovered' | 'system';
    title: string;
    message: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    timestamp: string;
    metadata?: any;
  }) => void;
  
  'api-check-complete': (data: {
    apiId: string;
    hasChanges: boolean;
    changeCount: number;
    timestamp: string;
  }) => void;
}

export function useRealtime() {
  const { user } = useAuth();
  const { subscribe, isConnected, emit } = useWebSocket();
  const queryClient = useQueryClient();

  // Real-time data invalidation helpers
  const dashboardRealtime = {
    invalidateStats: () => queryClient.invalidateQueries({ queryKey: dashboardQueryKeys.stats() }),
    invalidateOverview: () => queryClient.invalidateQueries({ queryKey: dashboardQueryKeys.overview() }),
    invalidateActivity: () => queryClient.invalidateQueries({ queryKey: dashboardQueryKeys.recentActivity() }),
    invalidateHealth: () => queryClient.invalidateQueries({ queryKey: dashboardQueryKeys.apiHealth() }),
    addRecentActivity: (activity: any) => {
      queryClient.setQueryData(dashboardQueryKeys.recentActivity(), (oldData: any) => {
        if (!oldData) return [activity];
        return [activity, ...oldData.slice(0, 9)]; // Keep last 10
      });
    },
  };

  const apiRealtime = {
    invalidateList: () => queryClient.invalidateQueries({ queryKey: apiQueryKeys.list() }),
    invalidateById: (apiId: string) => queryClient.invalidateQueries({ queryKey: apiQueryKeys.byId(apiId) }),
    updateApiInList: (apiId: string, updates: any) => {
      queryClient.setQueryData(apiQueryKeys.list(), (oldData: any) => {
        if (!oldData?.apis) return oldData;
        return {
          ...oldData,
          apis: oldData.apis.map((api: any) => 
            api._id === apiId ? { ...api, ...updates } : api
          ),
        };
      });
    },
  };

  const notificationRealtime = {
    invalidateList: () => queryClient.invalidateQueries({ queryKey: notificationQueryKeys.list() }),
    addNewNotification: (notification: any) => {
      queryClient.setQueryData(notificationQueryKeys.list(), (oldData: any) => {
        if (!oldData) return { notifications: [notification], total: 1 };
        return {
          notifications: [notification, ...oldData.notifications],
          total: oldData.total + 1,
        };
      });
    },
  };

  const changelogRealtime = {
    invalidateChanges: (apiId?: string) => {
      if (apiId) {
        queryClient.invalidateQueries({ queryKey: ['changelogs', apiId] });
      } else {
        queryClient.invalidateQueries({ queryKey: ['changelogs'] });
      }
    },
  };

  // Handle API change events
  const handleApiChange = useCallback(
    (data: Parameters<SocketEvents['api:change']>[0]) => {
      logger.log('Real-time API change received:', data);

      apiRealtime.updateApiInList(data.apiId, {
        lastChecked: data.timestamp,
        changeCount: data.changeCount,
      });

      dashboardRealtime.invalidateStats();
      dashboardRealtime.invalidateActivity();
      changelogRealtime.invalidateChanges(data.apiId);

      dashboardRealtime.addRecentActivity({
        id: `change-${Date.now()}`,
        type: 'api_change',
        title: `${data.apiName} Updated`,
        description: `${data.changeCount} ${data.changeType} change${data.changeCount > 1 ? 's' : ''} detected`,
        timestamp: data.timestamp,
        apiId: data.apiId,
        severity: data.severity,
      });

      const message = `${data.apiName}: ${data.changeCount} ${data.changeType} change${data.changeCount > 1 ? 's' : ''} detected`;
      
      switch (data.severity) {
        case 'critical':
          toast.error(message, { duration: 8000 });
          break;
        case 'high':
          toast.error(message, { duration: 6000 });
          break;
        case 'medium':
          toast(message, { duration: 4000 });
          break;
        default:
          toast.success(message);
          break;
      }
    },
    [apiRealtime, dashboardRealtime, changelogRealtime]
  );

  const handleApiHealth = useCallback(
    (data: Parameters<SocketEvents['api:health']>[0]) => {
      logger.log('Real-time API health update:', data);

      apiRealtime.updateApiInList(data.apiId, {
        healthStatus: data.status,
        lastHealthCheck: data.timestamp,
      });
      dashboardRealtime.invalidateStats();
      dashboardRealtime.invalidateHealth();

      if (data.status === 'unhealthy') {
        toast.error(`${data.apiName} is now unhealthy`);
      } else if (data.status === 'healthy' && data.previousStatus === 'unhealthy') {
        toast.success(`${data.apiName} is now healthy`);
      }
    },
    [apiRealtime, dashboardRealtime]
  );

  // Handle new notification events
  const handleNotification = useCallback(
    (data: Parameters<SocketEvents['notification']>[0]) => {
      logger.log('Real-time notification received:', data);

      notificationRealtime.addNewNotification({
        _id: data.id,
        userId: user?._id || '',
        type: data.type as any,
        title: data.title,
        message: data.message,
        severity: data.severity as any,
        read: false,
        channels: ['web'],
        deliveryStatus: {},
        createdAt: data.timestamp,
        updatedAt: data.timestamp,
      });
      const toastMessage = `${data.title}: ${data.message}`;
      switch (data.severity) {
        case 'critical':
          toast.error(toastMessage, { duration: 10000 });
          break;
        case 'high':
          toast.error(toastMessage, { duration: 7000 });
          break;
        case 'medium':
          toast(toastMessage, { duration: 5000 });
          break;
        default:
          toast.success(toastMessage);
          break;
      }
    },
    [notificationRealtime, user]
  );

  const handleApiCheckComplete = useCallback(
    (data: Parameters<SocketEvents['api-check-complete']>[0]) => {
      logger.log('API check complete:', data);
      changelogRealtime.invalidateChanges(data.apiId);
      dashboardRealtime.invalidateStats();

      if (data.hasChanges) {
        dashboardRealtime.addRecentActivity({
          id: `check-${Date.now()}`,
          type: 'api_change',
          title: 'API Check Complete',
          description: `${data.changeCount} changes found`,
          timestamp: data.timestamp,
          apiId: data.apiId,
          severity: data.changeCount > 0 ? 'medium' : 'low',
        });
      }
    },
    [dashboardRealtime, changelogRealtime]
  );

  useEffect(() => {
    if (!isConnected) return;

    const unsubscribers = [
      subscribe('api:change', handleApiChange),
      subscribe('api:health', handleApiHealth),
      subscribe('notification', handleNotification),
      subscribe('api-check-complete', handleApiCheckComplete),
    ];

    return () => {
      unsubscribers.forEach(unsubscribe => unsubscribe());
    };
  }, [
    isConnected,
    subscribe,
    handleApiChange,
    handleApiHealth,
    handleNotification,
    handleApiCheckComplete,
  ]);
  useEffect(() => {
    if (isConnected && user?._id) {
      emit('subscribe:user_apis');
    }
  }, [isConnected, user?._id, emit]);

  return {
    isConnected,
    dashboardRealtime,
    apiRealtime,
    notificationRealtime,
    changelogRealtime,
  };
}

// API MANAGEMENT COMPONENTS

// API Registration Form

'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import Layout from '@/components/layout/Layout';
import RouteGuard from '@/components/RouteGuard';
import { useCreateApi, useValidateApiUrl } from '@/hooks/useApis';
import { toast } from 'react-hot-toast';
import {
  Globe,
  Plus,
  ArrowLeft,
  CheckCircle,
  AlertCircle,
  Loader2,
  Tag,
  FileText,
} from 'lucide-react';

interface ApiFormData {
  apiName: string;
  openApiUrl: string;
  type: string;
  checkFrequency: string;
  tags: string[];
  description: string;
}

const AddApiPage = () => {
  const router = useRouter();
  const [formData, setFormData] = useState<ApiFormData>({
    apiName: '',
    openApiUrl: '',
    type: 'openapi',
    checkFrequency: '1h',
    tags: [],
    description: '',
  });

  const [tagInput, setTagInput] = useState('');
  const [isValidating, setIsValidating] = useState(false);
  const [validationResult, setValidationResult] = useState<any>(null);

  const createApiMutation = useCreateApi();
  const validateUrlMutation = useValidateApiUrl();

  // Handle form field changes
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Clear validation when URL changes
    if (name === 'openApiUrl') {
      setValidationResult(null);
    }
  };
  const handleAddTag = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter' && tagInput.trim()) {
      e.preventDefault();
      const newTag = tagInput.trim().toLowerCase();
      if (!formData.tags.includes(newTag)) {
        setFormData(prev => ({
          ...prev,
          tags: [...prev.tags, newTag],
        }));
      }
      setTagInput('');
    }
  };

  const removeTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(tag => tag !== tagToRemove),
    }));
  };

  // Validate API URL
  const handleValidateUrl = async () => {
    if (!formData.openApiUrl) {
      toast.error('Please enter an API URL first');
      return;
    }

    setIsValidating(true);
    try {
      const result = await validateUrlMutation.mutateAsync(formData.openApiUrl);
      setValidationResult(result);
      
      if (result.valid && result.apiInfo) {
        // Auto-fill form with detected info
        if (result.apiInfo.title && !formData.apiName) {
          setFormData(prev => ({ ...prev, apiName: result.apiInfo.title }));
        }
        if (result.apiInfo.description && !formData.description) {
          setFormData(prev => ({ ...prev, description: result.apiInfo.description }));
        }
        toast.success('API URL validated successfully!');
      } else {
        toast.error(result.error || 'Failed to validate API URL');
      }
    } catch (error: any) {
      toast.error(error.message || 'Validation failed');
      setValidationResult({ valid: false, error: error.message });
    } finally {
      setIsValidating(false);
    }
  };
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!validationResult?.valid) {
      toast.error('Please validate the API URL first');
      return;
    }

    try {
      await createApiMutation.mutateAsync(formData);
      toast.success('API registered successfully!');
      router.push('/apis');
    } catch (error: any) {
      toast.error(error.message || 'Failed to register API');
    }
  };

  const isSubmitting = createApiMutation.isPending;

  return (
    <RouteGuard requireAuth={true}>
      <Layout>
        <div className="max-w-2xl mx-auto">
          {/* Header */}
          <div className="mb-8">
            <button
              onClick={() => router.back()}
              className="flex items-center text-sm text-gray-500 hover:text-gray-700 mb-4"
            >
              <ArrowLeft className="w-4 h-4 mr-1" />
              Back
            </button>
            <h1 className="text-2xl font-bold text-gray-900">Add New API</h1>
            <p className="mt-2 text-sm text-gray-600">
              Register a new API for monitoring. We'll track changes and notify you of updates.
            </p>
          </div>

          {/* Form */}
          <div className="bg-white shadow rounded-lg">
            <form onSubmit={handleSubmit} className="space-y-6 p-6">
              {/* API URL Field */}
              <div>
                <label htmlFor="openApiUrl" className="block text-sm font-medium text-gray-700">
                  OpenAPI Specification URL *
                </label>
                <div className="mt-1 flex rounded-md shadow-sm">
                  <div className="relative flex flex-grow items-stretch">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <Globe className="h-5 w-5 text-gray-400" />
                    </div>
                    <input
                      type="url"
                      name="openApiUrl"
                      id="openApiUrl"
                      value={formData.openApiUrl}
                      onChange={handleChange}
                      className="focus:ring-blue-500 focus:border-blue-500 block w-full rounded-none rounded-l-md pl-10 sm:text-sm border-gray-300"
                      placeholder="https://api.example.com/openapi.json"
                      required
                    />
                  </div>
                  <button
                    type="button"
                    onClick={handleValidateUrl}
                    disabled={isValidating || !formData.openApiUrl}
                    className="relative -ml-px inline-flex items-center space-x-2 rounded-r-md border border-gray-300 bg-gray-50 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500 disabled:opacity-50"
                  >
                    {isValidating ? (
                      <Loader2 className="h-4 w-4 animate-spin" />
                    ) : (
                      <CheckCircle className="h-4 w-4" />
                    )}
                    <span>Validate</span>
                  </button>
                </div>
                
                {/* Validation Result */}
                {validationResult && (
                  <div className={`mt-2 p-3 rounded-md ${
                    validationResult.valid 
                      ? 'bg-green-50 border border-green-200' 
                      : 'bg-red-50 border border-red-200'
                  }`}>
                    <div className="flex">
                      <div className="flex-shrink-0">
                        {validationResult.valid ? (
                          <CheckCircle className="h-5 w-5 text-green-400" />
                        ) : (
                          <AlertCircle className="h-5 w-5 text-red-400" />
                        )}
                      </div>
                      <div className="ml-3">
                        <p className={`text-sm ${
                          validationResult.valid ? 'text-green-800' : 'text-red-800'
                        }`}>
                          {validationResult.valid 
                            ? 'API URL is valid and accessible' 
                            : validationResult.error || 'Validation failed'
                          }
                        </p>
                        {validationResult.valid && validationResult.apiInfo && (
                          <div className="mt-2 text-xs text-green-700">
                            <p><strong>Title:</strong> {validationResult.apiInfo.title}</p>
                            <p><strong>Version:</strong> {validationResult.apiInfo.version}</p>
                            {validationResult.responseTime && (
                              <p><strong>Response Time:</strong> {validationResult.responseTime}ms</p>
                            )}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                )}
              </div>

              {/* API Name */}
              <div>
                <label htmlFor="apiName" className="block text-sm font-medium text-gray-700">
                  API Name *
                </label>
                <input
                  type="text"
                  name="apiName"
                  id="apiName"
                  value={formData.apiName}
                  onChange={handleChange}
                  className="mt-1 focus:ring-blue-500 focus:border-blue-500 block w-full shadow-sm sm:text-sm border-gray-300 rounded-md"
                  placeholder="My API"
                  required
                />
              </div>

              {/* Description */}
              <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-700">
                  Description
                </label>
                <textarea
                  name="description"
                  id="description"
                  value={formData.description}
                  onChange={handleChange}
                  rows={3}
                  className="mt-1 focus:ring-blue-500 focus:border-blue-500 block w-full shadow-sm sm:text-sm border-gray-300 rounded-md"
                  placeholder="Brief description of what this API does..."
                />
              </div>

              {/* Check Frequency */}
              <div>
                <label htmlFor="checkFrequency" className="block text-sm font-medium text-gray-700">
                  Check Frequency
                </label>
                <select
                  name="checkFrequency"
                  id="checkFrequency"
                  value={formData.checkFrequency}
                  onChange={handleChange}
                  className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md"
                >
                  <option value="30s">Every 30 seconds</option>
                  <option value="1m">Every minute</option>
                  <option value="5m">Every 5 minutes</option>
                  <option value="15m">Every 15 minutes</option>
                  <option value="1h">Every hour</option>
                  <option value="6h">Every 6 hours</option>
                  <option value="1d">Daily</option>
                </select>
              </div>

              {/* Tags */}
              <div>
                <label htmlFor="tags" className="block text-sm font-medium text-gray-700">
                  Tags
                </label>
                <div className="mt-1">
                  <input
                    type="text"
                    value={tagInput}
                    onChange={(e) => setTagInput(e.target.value)}
                    onKeyDown={handleAddTag}
                    className="focus:ring-blue-500 focus:border-blue-500 block w-full shadow-sm sm:text-sm border-gray-300 rounded-md"
                    placeholder="Type a tag and press Enter"
                  />
                  {formData.tags.length > 0 && (
                    <div className="mt-2 flex flex-wrap gap-2">
                      {formData.tags.map((tag) => (
                        <span
                          key={tag}
                          className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800"
                        >
                          <Tag className="w-3 h-3 mr-1" />
                          {tag}
                          <button
                            type="button"
                            onClick={() => removeTag(tag)}
                            className="ml-1 text-blue-600 hover:text-blue-800"
                          >
                            ×
                          </button>
                        </span>
                      ))}
                    </div>
                  )}
                </div>
                <p className="mt-1 text-sm text-gray-500">
                  Add tags to categorize and filter your APIs
                </p>
              </div>

              {/* Submit Button */}
              <div className="flex justify-end space-x-3">
                <button
                  type="button"
                  onClick={() => router.back()}
                  className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={isSubmitting || !validationResult?.valid}
                  className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                  {isSubmitting ? (
                    <>
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      Registering...
                    </>
                  ) : (
                    <>
                      <Plus className="w-4 h-4 mr-2" />
                      Register API
                    </>
                  )}
                </button>
              </div>
            </form>
          </div>
        </div>
      </Layout>
    </RouteGuard>
  );
};

export default AddApiPage;

// AUTHENTICATION & SECURITY

// Route Guard Component

'use client';

import { useAuthHooks } from '@/hooks/useAuth';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';

interface RouteGuardProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  redirectTo?: string;
}

export const RouteGuard = ({
  children,
  requireAuth = false,
  redirectTo,
}: RouteGuardProps) => {
  const { isAuthenticated, isLoading } = useAuthHooks();
  const router = useRouter();

  useEffect(() => {
    if (isLoading) return;

    if (requireAuth && !isAuthenticated) {
      router.replace('/login');
      return;
    }

    if (!requireAuth && isAuthenticated) {
      const defaultRedirect = redirectTo || '/dashboard';
      router.replace(defaultRedirect);
      return;
    }
  }, [isAuthenticated, isLoading, requireAuth, router, redirectTo]);

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Loading...</p>
        </div>
      </div>
    );
  }

  if (requireAuth && !isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Redirecting to login...</p>
        </div>
      </div>
    );
  }

  if (!requireAuth && isAuthenticated) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
          <p className="mt-4 text-gray-600">Redirecting to dashboard...</p>
        </div>
      </div>
    );
  }

  return <>{children}</>;
};

// Authentication Hook

'use client';

import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { authService } from '@/services/auth.service';
import { toast } from 'react-hot-toast';

export interface User {
  _id: string;
  email: string;
  role: string;
  isEmailVerified: boolean;
  profilePicture?: string;
  lastLoginAt?: string;
  isActive: boolean;
  notificationPreferences: {
    email: boolean;
    breakingChanges: boolean;
    nonBreakingChanges: boolean;
    apiErrors: boolean;
  };
  createdAt: string;
  updatedAt: string;
  api_key?: string;
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
}

interface AuthActions {
  login: (user: User) => void;
  logout: () => void;
  updateUser: (userData: Partial<User>) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  clearError: () => void;
}

export type AuthStore = AuthState & AuthActions;

interface RegisterData {
  email: string;
  password: string;
  role?: string;
}

export const useAuth = create<AuthStore>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,
      isLoading: false,

      login: async (email: string, password: string) => {
        set({ isLoading: true });
        try {
          const response = await authService.login({ email, password });
          if (response.success) {
            set({
              user: response.data.user,
              token: response.data.token,
              isAuthenticated: true,
              isLoading: false,
            });
            toast.success('Login successful!');
          }
        } catch (error: any) {
          set({ isLoading: false });
          toast.error(error.message || 'Login failed');
          throw error;
        }
      },

      register: async (data: RegisterData) => {
        set({ isLoading: true });
        try {
          const response = await authService.register(data);
          if (response.success) {
            set({
              user: response.data.user,
              token: response.data.token,
              isAuthenticated: true,
              isLoading: false,
            });
            toast.success('Registration successful!');
          }
        } catch (error: any) {
          set({ isLoading: false });
          toast.error(error.message || 'Registration failed');
          throw error;
        }
      },

      logout: () => {
        set({
          user: null,
          token: null,
          isAuthenticated: false,
          isLoading: false,
        });
        toast.success('Logged out successfully');
      },

      updateProfile: async (data: Partial<User>) => {
        const { user } = get();
        if (!user) return;

        try {
          const response = await authService.updateProfile(data);
          if (response.success) {
            set({
              user: { ...user, ...response.data },
            });
            toast.success('Profile updated successfully!');
          }
        } catch (error: any) {
          toast.error(error.message || 'Failed to update profile');
          throw error;
        }
      },

      refreshToken: async () => {
        try {
          const response = await authService.refreshToken();
          if (response.success) {
            set({
              user: response.data.user,
              token: response.data.token,
            });
          }
        } catch (error) {
          get().logout();
        }
      },

      resetPassword: async (email: string) => {
        try {
          await authService.resetPassword(email);
          toast.success('Password reset email sent!');
        } catch (error: any) {
          toast.error(error.message || 'Failed to send reset email');
          throw error;
        }
      },

      changePassword: async (currentPassword: string, newPassword: string) => {
        try {
          await authService.changePassword(currentPassword, newPassword);
          toast.success('Password changed successfully!');
        } catch (error: any) {
          toast.error(error.message || 'Failed to change password');
          throw error;
        }
      },
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);

export const useAuthUser = () => useAuth((state) => state.user);
export const useIsAuthenticated = () => useAuth((state) => state.isAuthenticated);
export const useAuthLoading = () => useAuth((state) => state.isLoading);
export const useAuthError = () => useAuth((state) => state.error);

export const useAuthHooks = () => {
  const {
    user,
    isAuthenticated,
    isLoading,
    error,
    login: setAuthData,
    logout: clearAuthData,
    updateUser,
    setLoading,
    setError,
  } = useAuth();

  const login = ({ email, password }: { email: string; password: string }) => {
    setLoading(true);
  };

  const register = ({ email, password, role }: { email: string; password: string; role?: string }) => {
    setLoading(true);
  };

  return {
    user,
    isAuthenticated,
    isLoading,
    error,
    login,
    register,
    logout: clearAuthData,
    updateUser,
    setLoading,
    setError,
    isLoginPending: isLoading,
    isRegisterPending: isLoading,
  };
};

// NAVIGATION & LAYOUT COMPONENTS

// Navigation Menu

'use client';

import React, { useState, useEffect } from 'react';
import { usePathname } from 'next/navigation';
import Link from 'next/link';
import {
  Home,
  Activity,
  Plus,
  Settings,
  Bell,
  BarChart3,
  Users,
  Shield,
  Calendar,
  FileText,
  LogOut,
  ChevronDown,
  ChevronRight,
  X,
  GitCommit,
  AlertTriangle,
} from 'lucide-react';
import { useAuth } from '@/store/auth';
import { useNotifications } from '@/hooks/useNotifications';
import { clsx } from 'clsx';

interface NavigationItem {
  id: string;
  label: string;
  href: string;
  icon: React.ComponentType<any>;
  badge?: number;
  children?: NavigationItem[];
  requiresAuth?: boolean;
  adminOnly?: boolean;
}

interface NavigationMenuProps {
  isOpen: boolean;
  onToggle: () => void;
  className?: string;
}

const NavigationMenu: React.FC<NavigationMenuProps> = ({
  isOpen,
  onToggle,
  className = '',
}) => {
  const pathname = usePathname();
  const { user, logout } = useAuth();
  const { data: notificationsData } = useNotifications();
  const [expandedItems, setExpandedItems] = useState<string[]>([]);

  const unreadCount =
    notificationsData?.notifications?.filter((n: any) => !n.read)?.length || 0;

  const navigationItems: NavigationItem[] = [
    {
      id: 'dashboard',
      label: 'Dashboard',
      href: '/dashboard',
      icon: Home,
    },
    {
      id: 'apis',
      label: 'APIs',
      href: '/apis',
      icon: Activity,
      children: [
        {
          id: 'apis-list',
          label: 'All APIs',
          href: '/apis',
          icon: Activity,
        },
        {
          id: 'apis-add',
          label: 'Add API',
          href: '/add-api',
          icon: Plus,
        },
        {
          id: 'apis-changes',
          label: 'Changes',
          href: '/changes',
          icon: GitCommit,
        },
        {
          id: 'apis-issues',
          label: 'Issues',
          href: '/issues',
          icon: AlertTriangle,
        },
        {
          id: 'apis-monitoring',
          label: 'Monitoring',
          href: '/apis/monitoring',
          icon: BarChart3,
        },
      ],
    },
    {
      id: 'changes',
      label: 'Changes',
      href: '/changes',
      icon: GitCommit,
    },
    {
      id: 'issues',
      label: 'Issues',
      href: '/issues',
      icon: AlertTriangle,
    },
    {
      id: 'notifications',
      label: 'Notifications',
      href: '/notifications',
      icon: Bell,
      badge: unreadCount,
    },
    {
      id: 'analytics',
      label: 'Analytics',
      href: '/analytics',
      icon: BarChart3,
      children: [
        {
          id: 'analytics-overview',
          label: 'Overview',
          href: '/analytics',
          icon: BarChart3,
        },
        {
          id: 'analytics-reports',
          label: 'Reports',
          href: '/analytics/reports',
          icon: FileText,
        },
        {
          id: 'analytics-trends',
          label: 'Trends',
          href: '/analytics/trends',
          icon: Calendar,
        },
      ],
    },
    {
      id: 'team',
      label: 'Team',
      href: '/team',
      icon: Users,
      requiresAuth: true,
      children: [
        {
          id: 'team-members',
          label: 'Members',
          href: '/team/members',
          icon: Users,
        },
        {
          id: 'team-permissions',
          label: 'Permissions',
          href: '/team/permissions',
          icon: Shield,
          adminOnly: true,
        },
      ],
    },
    {
      id: 'settings',
      label: 'Settings',
      href: '/settings',
      icon: Settings,
      children: [
        {
          id: 'settings-profile',
          label: 'Profile',
          href: '/settings/profile',
          icon: Users,
        },
        {
          id: 'settings-notifications',
          label: 'Notifications',
          href: '/settings/notifications',
          icon: Bell,
        },
        {
          id: 'settings-security',
          label: 'Security',
          href: '/settings/security',
          icon: Shield,
        },
      ],
    },
  ];

  const toggleExpanded = (itemId: string) => {
    setExpandedItems(prev =>
      prev.includes(itemId)
        ? prev.filter(id => id !== itemId)
        : [...prev, itemId]
    );
  };

  const isActive = (href: string) => {
    if (href === '/dashboard' && pathname === '/dashboard') return true;
    if (href !== '/dashboard' && pathname.startsWith(href)) return true;
    return false;
  };

  const handleLogout = () => {
    logout();
  };

  if (!isOpen) return null;

  return (
    <div className={clsx(
      'fixed inset-0 z-50 lg:static lg:inset-auto',
      'lg:w-64 lg:flex-shrink-0',
      className
    )}>
      {/* Overlay for mobile */}
      <div
        className="fixed inset-0 bg-gray-600 bg-opacity-75 lg:hidden"
        onClick={onToggle}
      />

      {/* Sidebar */}
      <div className="relative flex w-64 flex-col bg-white border-r border-gray-200 h-full">
        {/* Header */}
        <div className="flex items-center justify-between h-16 px-4 border-b border-gray-200">
          <Link href="/dashboard" className="flex items-center space-x-2">
            <div className="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center">
              <Activity className="w-5 h-5 text-white" />
            </div>
            <span className="text-xl font-bold text-gray-900">APILens</span>
          </Link>
          <button
            onClick={onToggle}
            className="lg:hidden p-1 rounded-md text-gray-400 hover:text-gray-500"
          >
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Navigation */}
        <nav className="flex-1 overflow-y-auto py-4">
          <ul className="space-y-1 px-2">
            {navigationItems.map((item) => (
              <NavigationItem
                key={item.id}
                item={item}
                pathname={pathname}
                expandedItems={expandedItems}
                onToggleExpanded={toggleExpanded}
                user={user}
              />
            ))}
          </ul>
        </nav>

        {/* User Section */}
        {user && (
          <div className="border-t border-gray-200 p-4">
            <div className="flex items-center">
              <div className="flex-shrink-0">
                <div className="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                  <span className="text-sm font-medium text-blue-600">
                    {user.name.charAt(0).toUpperCase()}
                  </span>
                </div>
              </div>
              <div className="ml-3 flex-1">
                <p className="text-sm font-medium text-gray-900">{user.name}</p>
                <p className="text-xs text-gray-500">{user.email}</p>
              </div>
              <button
                onClick={handleLogout}
                className="ml-2 p-1 rounded-md text-gray-400 hover:text-gray-500"
                title="Logout"
              >
                <LogOut className="w-5 h-5" />
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// ANALYTICS COMPONENTS

// Analytics Page

'use client';

import React, { useState } from 'react';
import Layout from '@/components/layout/Layout';
import RouteGuard from '@/components/RouteGuard';
import { useApis } from '@/hooks/useApis';
import { BarChart3, TrendingUp, Activity, Zap, AlertTriangle, Loader2 } from 'lucide-react';
import {
  PieChart,
  Pie,
  Cell,
  ResponsiveContainer,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  LineChart,
  Line,
} from 'recharts';

const AnalyticsPage = () => {
  const { data: apis, isLoading } = useApis();
  const [activeTab, setActiveTab] = useState('overview');

  const tabs = [
    { id: 'overview', label: 'Overview', icon: BarChart3 },
    { id: 'status', label: 'API Status', icon: Activity },
    { id: 'health', label: 'Health Metrics', icon: Zap },
    { id: 'changes', label: 'Change Trends', icon: TrendingUp },
  ];

  if (isLoading) {
    return (
      <RouteGuard requireAuth={true}>
        <Layout>
          <div className="flex items-center justify-center min-h-96">
            <div className="flex items-center space-x-3">
              <Loader2 className="w-8 h-8 animate-spin text-blue-600" />
              <span className="text-lg text-gray-600">Loading analytics...</span>
            </div>
          </div>
        </Layout>
      </RouteGuard>
    );
  }

  const activeApis = apis?.filter((api: any) => api.isActive) || [];
  const healthyApis = apis?.filter((api: any) => api.healthStatus === 'healthy') || [];
  const criticalApis = apis?.filter((api: any) => api.healthStatus === 'error') || [];

  const statusData = [
    { name: 'Active', value: activeApis.length, color: '#10B981' },
    { name: 'Inactive', value: (apis?.length || 0) - activeApis.length, color: '#6B7280' },
  ];

  const healthData = [
    { name: 'Healthy', value: healthyApis.length, color: '#10B981' },
    { name: 'Warning', value: apis?.filter((api: any) => api.healthStatus === 'warning').length || 0, color: '#F59E0B' },
    { name: 'Critical', value: criticalApis.length, color: '#EF4444' },
  ];

  const changeData = [
    { name: 'User API', changes: 15 },
    { name: 'Payment API', changes: 22 },
    { name: 'Orders API', changes: 8 },
    { name: 'Notifications API', changes: 12 },
    { name: 'Weather API', changes: 5 },
    { name: 'Pet Store API', changes: 3 },
  ];

  return (
    <RouteGuard requireAuth={true}>
      <Layout>
        <div className="min-h-screen bg-gray-50">
          <div className="p-6 mx-auto max-w-7xl">
            <div className="mb-8">
              <h1 className="mb-2 text-3xl font-bold text-gray-900">Analytics Dashboard</h1>
              <p className="text-gray-600">Comprehensive insights into your API ecosystem</p>
            </div>

            {/* Summary Cards */}
            <div className="grid grid-cols-1 gap-6 mb-8 md:grid-cols-4">
              <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                <div className="flex items-center">
                  <div className="p-2 bg-blue-100 rounded-lg">
                    <Activity className="w-6 h-6 text-blue-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-500">Total APIs</p>
                    <p className="text-2xl font-semibold text-gray-900">{apis?.length || 0}</p>
                  </div>
                </div>
              </div>

              <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                <div className="flex items-center">
                  <div className="p-2 bg-green-100 rounded-lg">
                    <Zap className="w-6 h-6 text-green-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-500">Healthy APIs</p>
                    <p className="text-2xl font-semibold text-gray-900">{healthyApis.length}</p>
                  </div>
                </div>
              </div>

              <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                <div className="flex items-center">
                  <div className="p-2 bg-red-100 rounded-lg">
                    <AlertTriangle className="w-6 h-6 text-red-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-500">Critical Issues</p>
                    <p className="text-2xl font-semibold text-gray-900">{criticalApis.length}</p>
                  </div>
                </div>
              </div>

              <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                <div className="flex items-center">
                  <div className="p-2 bg-yellow-100 rounded-lg">
                    <TrendingUp className="w-6 h-6 text-yellow-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-500">Avg Response Time</p>
                    <p className="text-2xl font-semibold text-gray-900">245ms</p>
                  </div>
                </div>
              </div>
            </div>

            {/* Tab Navigation */}
            <div className="mb-6">
              <nav className="flex space-x-8">
                {tabs.map((tab) => (
                  <button
                    key={tab.id}
                    onClick={() => setActiveTab(tab.id)}
                    className={clsx(
                      'flex items-center px-3 py-2 text-sm font-medium rounded-md',
                      activeTab === tab.id
                        ? 'bg-blue-100 text-blue-700'
                        : 'text-gray-500 hover:text-gray-700'
                    )}
                  >
                    <tab.icon className="w-5 h-5 mr-2" />
                    {tab.label}
                  </button>
                ))}
              </nav>
            </div>

            {/* Chart Content */}
            <div className="space-y-6">
              {activeTab === 'overview' && (
                <div className="grid grid-cols-1 gap-6 lg:grid-cols-2">
                  <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                    <h3 className="mb-4 text-lg font-medium text-gray-900">API Status Distribution</h3>
                    <div className="h-64">
                      <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                          <Pie
                            data={statusData}
                            cx="50%"
                            cy="50%"
                            labelLine={false}
                            label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                            outerRadius={80}
                            fill="#8884d8"
                            dataKey="value"
                          >
                            {statusData.map((entry, index) => (
                              <Cell key={`cell-${index}`} fill={entry.color} />
                            ))}
                          </Pie>
                          <Tooltip />
                        </PieChart>
                      </ResponsiveContainer>
                    </div>
                  </div>

                  <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                    <h3 className="mb-4 text-lg font-medium text-gray-900">Health Status</h3>
                    <div className="h-64">
                      <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                          <Pie
                            data={healthData}
                            cx="50%"
                            cy="50%"
                            labelLine={false}
                            label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
                            outerRadius={80}
                            fill="#8884d8"
                            dataKey="value"
                          >
                            {healthData.map((entry, index) => (
                              <Cell key={`cell-${index}`} fill={entry.color} />
                            ))}
                          </Pie>
                          <Tooltip />
                        </PieChart>
                      </ResponsiveContainer>
                    </div>
                  </div>
                </div>
              )}

              {activeTab === 'changes' && (
                <div className="p-6 bg-white border border-gray-200 rounded-lg shadow-sm">
                  <h3 className="mb-4 text-lg font-medium text-gray-900">API Changes This Month</h3>
                  <div className="h-80">
                    <ResponsiveContainer width="100%" height="100%">
                      <BarChart data={changeData}>
                        <CartesianGrid strokeDasharray="3 3" />
                        <XAxis dataKey="name" />
                        <YAxis />
                        <Tooltip />
                        <Legend />
                        <Bar dataKey="changes" fill="#3B82F6" />
                      </BarChart>
                    </ResponsiveContainer>
                  </div>
                </div>
              )}
            </div>

            <div className="mt-12 text-sm text-center text-gray-500">
              <p>Analytics data is updated in real-time. Last refresh: {new Date().toLocaleTimeString()}</p>
            </div>
          </div>
        </div>
      </Layout>
    </RouteGuard>
  );
};

export default AnalyticsPage;

// NOTIFICATIONS MANAGEMENT

// Notifications Page

'use client';

import React, { useState } from 'react';
import { useRouter } from 'next/navigation';
import Layout from '@/components/layout/Layout';
import RouteGuard from '@/components/RouteGuard';
import {
  useInfiniteNotifications,
  useUnreadCount,
  useMarkAsRead,
  useMarkAllAsRead,
  useDeleteNotification,
} from '@/hooks/useNotifications';
import {
  Bell,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Clock,
  ExternalLink,
  Check,
  X,
  RefreshCw,
  Filter,
  ChevronDown,
  Loader2,
} from 'lucide-react';
import { clsx } from 'clsx';
import { formatDistanceToNow } from 'date-fns';

type SeverityFilter = 'all' | 'critical' | 'high' | 'medium' | 'low';
type TypeFilter = 'all' | 'api_change' | 'api_error' | 'api_recovered' | 'system';
type ReadFilter = 'all' | 'unread' | 'read';

const NotificationsPage = () => {
  const router = useRouter();
  const [severityFilter, setSeverityFilter] = useState<SeverityFilter>('all');
  const [typeFilter, setTypeFilter] = useState<TypeFilter>('all');
  const [readFilter, setReadFilter] = useState<ReadFilter>('all');
  const [showFilters, setShowFilters] = useState(false);

  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
    refetch,
  } = useInfiniteNotifications({
    limit: 20,
    unreadOnly: readFilter === 'unread',
  });

  const { data: unreadCount = 0 } = useUnreadCount();
  const markAsReadMutation = useMarkAsRead();
  const markAllAsReadMutation = useMarkAllAsRead();
  const deleteNotificationMutation = useDeleteNotification();

  const notifications = data?.pages.flatMap(page => page.notifications) || [];

  const filteredNotifications = notifications.filter(notification => {
    if (severityFilter !== 'all' && notification.severity !== severityFilter) return false;
    if (typeFilter !== 'all' && notification.type !== typeFilter) return false;
    if (readFilter === 'unread' && notification.read) return false;
    if (readFilter === 'read' && !notification.read) return false;
    return true;
  });

  const handleMarkAsRead = async (notificationId: string) => {
    try {
      await markAsReadMutation.mutateAsync(notificationId);
    } catch (error) {
      console.error('Failed to mark notification as read:', error);
    }
  };

  const handleMarkAllAsRead = async () => {
    try {
      await markAllAsReadMutation.mutateAsync();
    } catch (error) {
      console.error('Failed to mark all notifications as read:', error);
    }
  };

  const handleDeleteNotification = async (notificationId: string) => {
    try {
      await deleteNotificationMutation.mutateAsync(notificationId);
    } catch (error) {
      console.error('Failed to delete notification:', error);
    }
  };

  const getSeverityIcon = (severity: string) => {
    switch (severity) {
      case 'critical':
        return <AlertTriangle className="w-5 h-5 text-red-600" />;
      case 'high':
        return <AlertTriangle className="w-5 h-5 text-orange-600" />;
      case 'medium':
        return <Clock className="w-5 h-5 text-yellow-600" />;
      case 'low':
        return <CheckCircle className="w-5 h-5 text-blue-600" />;
      default:
        return <Bell className="w-5 h-5 text-gray-600" />;
    }
  };

  const getSeverityColor = (severity: string) => {
    switch (severity) {
      case 'critical':
        return 'bg-red-100 text-red-800 border-red-200';
      case 'high':
        return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'medium':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'low':
        return 'bg-blue-100 text-blue-800 border-blue-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  if (isLoading) {
    return (
      <RouteGuard requireAuth={true}>
        <Layout>
          <div className="flex items-center justify-center min-h-96">
            <Loader2 className="w-8 h-8 text-blue-600 animate-spin" />
          </div>
        </Layout>
      </RouteGuard>
    );
  }

  if (isError) {
    return (
      <RouteGuard requireAuth={true}>
        <Layout>
          <div className="flex items-center justify-center min-h-96">
            <div className="text-center">
              <XCircle className="w-16 h-16 mx-auto mb-4 text-red-500" />
              <h2 className="mb-2 text-xl font-semibold text-gray-900">
                Failed to load notifications
              </h2>
              <p className="text-gray-600">
                Please try refreshing the page or contact support if the issue persists.
              </p>
            </div>
          </div>
        </Layout>
      </RouteGuard>
    );
  }

  return (
    <RouteGuard requireAuth={true}>
      <Layout>
        <div className="max-w-4xl p-6 mx-auto">
          <div className="mb-8">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-2xl font-bold text-gray-900">Notifications</h1>
                <p className="mt-1 text-sm text-gray-500">
                  Stay updated with API changes and system alerts
                  {unreadCount > 0 && (
                    <span className="ml-2 inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-red-100 text-red-800">
                      {unreadCount} unread
                    </span>
                  )}
                </p>
              </div>

              <div className="flex items-center space-x-3">
                <button
                  onClick={() => setShowFilters(!showFilters)}
                  className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
                >
                  <Filter className="w-4 h-4 mr-2" />
                  Filters
                  <ChevronDown className="w-4 h-4 ml-2" />
                </button>

                {unreadCount > 0 && (
                  <button
                    onClick={handleMarkAllAsRead}
                    disabled={markAllAsReadMutation.isPending}
                    className="inline-flex items-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
                  >
                    <Check className="w-4 h-4 mr-2" />
                    Mark All Read
                  </button>
                )}

                <button
                  onClick={() => refetch()}
                  className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50"
                >
                  <RefreshCw className="w-4 h-4" />
                </button>
              </div>
            </div>

            {/* Filters */}
            {showFilters && (
              <div className="mt-4 p-4 bg-gray-50 rounded-lg">
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Severity
                    </label>
                    <select
                      value={severityFilter}
                      onChange={(e) => setSeverityFilter(e.target.value as SeverityFilter)}
                      className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm"
                    >
                      <option value="all">All Severities</option>
                      <option value="critical">Critical</option>
                      <option value="high">High</option>
                      <option value="medium">Medium</option>
                      <option value="low">Low</option>
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Type
                    </label>
                    <select
                      value={typeFilter}
                      onChange={(e) => setTypeFilter(e.target.value as TypeFilter)}
                      className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm"
                    >
                      <option value="all">All Types</option>
                      <option value="api_change">API Changes</option>
                      <option value="api_error">API Errors</option>
                      <option value="api_recovered">API Recovered</option>
                      <option value="system">System</option>
                    </select>
                  </div>

                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">
                      Status
                    </label>
                    <select
                      value={readFilter}
                      onChange={(e) => setReadFilter(e.target.value as ReadFilter)}
                      className="w-full border border-gray-300 rounded-md px-3 py-2 text-sm"
                    >
                      <option value="all">All Notifications</option>
                      <option value="unread">Unread Only</option>
                      <option value="read">Read Only</option>
                    </select>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Notifications List */}
          <div className="space-y-4">
            {filteredNotifications.length === 0 ? (
              <div className="py-12 text-center">
                <Bell className="w-16 h-16 mx-auto mb-4 text-gray-300" />
                <h3 className="mb-2 text-lg font-medium text-gray-900">
                  No notifications found
                </h3>
                <p className="text-gray-600">
                  {readFilter === 'unread' 
                    ? "You're all caught up! No unread notifications."
                    : severityFilter !== 'all' || typeFilter !== 'all'
                      ? 'Try adjusting your filters to see more notifications.'
                      : 'Notifications will appear here when there are API changes or issues.'
                  }
                </p>
              </div>
            ) : (
              filteredNotifications.map((notification) => (
                <div
                  key={notification._id}
                  className={clsx(
                    'bg-white border rounded-lg p-4 hover:shadow-md transition-shadow',
                    !notification.read ? 'border-blue-200 bg-blue-50' : 'border-gray-200'
                  )}
                >
                  <div className="flex items-start justify-between">
                    <div className="flex items-start space-x-3 flex-1">
                      <div className="flex-shrink-0 mt-1">
                        {getSeverityIcon(notification.severity)}
                      </div>

                      <div className="flex-1 min-w-0">
                        <div className="flex items-center space-x-2 mb-1">
                          <h3 className="text-sm font-medium text-gray-900">
                            {notification.title}
                          </h3>
                          <span className={clsx(
                            'inline-flex items-center px-2 py-1 rounded-full text-xs font-medium border',
                            getSeverityColor(notification.severity)
                          )}>
                            {notification.severity}
                          </span>
                          {!notification.read && (
                            <span className="w-2 h-2 bg-blue-500 rounded-full"></span>
                          )}
                        </div>

                        <p className="text-sm text-gray-600 mb-2">
                          {notification.message}
                        </p>

                        <div className="flex items-center space-x-4 text-xs text-gray-500">
                          <span>
                            {formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true })}
                          </span>
                          <span className="capitalize">
                            {notification.type.replace('_', ' ')}
                          </span>
                        </div>
                      </div>
                    </div>

                    <div className="flex items-center space-x-2 ml-4">
                      {!notification.read && (
                        <button
                          onClick={() => handleMarkAsRead(notification._id)}
                          className="p-1 text-gray-400 hover:text-blue-600"
                          title="Mark as read"
                        >
                          <Check className="w-4 h-4" />
                        </button>
                      )}

                      <button
                        onClick={() => handleDeleteNotification(notification._id)}
                        className="p-1 text-gray-400 hover:text-red-600"
                        title="Delete notification"
                      >
                        <X className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                </div>
              ))
            )}

            {/* Load More Button */}
            {hasNextPage && (
              <div className="text-center py-4">
                <button
                  onClick={() => fetchNextPage()}
                  disabled={isFetchingNextPage}
                  className="inline-flex items-center px-4 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 disabled:opacity-50"
                >
                  {isFetchingNextPage ? (
                    <>
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                      Loading...
                    </>
                  ) : (
                    'Load More'
                  )}
                </button>
              </div>
            )}
          </div>
        </div>
      </Layout>
    </RouteGuard>
  );
};

export default NotificationsPage;

// SETTINGS & CONFIGURATION

// Settings Page

'use client';

import React, { useState, useEffect } from 'react';
import Layout from '@/components/layout/Layout';
import RouteGuard from '@/components/RouteGuard';
import { useAuth } from '@/store/auth';
import { useNotificationPreferences, useUpdateNotificationPreferences } from '@/hooks/useNotifications';
import { toast } from 'react-hot-toast';
import {
  User,
  Bell,
  Shield,
  Save,
  Mail,
  MessageSquare,
  Webhook,
  Globe,
} from 'lucide-react';

const SettingsPage = () => {
  const { user, updateProfile } = useAuth();
  const { data: preferences, isLoading: preferencesLoading } = useNotificationPreferences();
  const updatePreferencesMutation = useUpdateNotificationPreferences();

  const [formData, setFormData] = useState({
    name: user?.name || '',
    email: user?.email || '',
    notificationPreferences: {
      email: true,
      slack: false,
      webhook: false,
      inApp: true,
    },
  });

  useEffect(() => {
    if (user) {
      setFormData(prev => ({
        ...prev,
        name: user.name,
        email: user.email,
        notificationPreferences: user.notificationPreferences || prev.notificationPreferences,
      }));
    }
  }, [user]);

  useEffect(() => {
    if (preferences) {
      setFormData(prev => ({
        ...prev,
        notificationPreferences: preferences,
      }));
    }
  }, [preferences]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      await updateProfile({
        name: formData.name,
        email: formData.email,
      });
      await updatePreferencesMutation.mutateAsync(formData.notificationPreferences);

      toast.success('Settings updated successfully!');
    } catch (error) {
      toast.error('Failed to update settings');
    }
  };

  const handleNotificationChange = (key: keyof typeof formData.notificationPreferences) => {
    setFormData(prev => ({
      ...prev,
      notificationPreferences: {
        ...prev.notificationPreferences,
        [key]: !prev.notificationPreferences[key],
      },
    }));
  };

  return (
    <RouteGuard requireAuth={true}>
      <Layout>
        <div className="p-6 max-w-4xl mx-auto">
          <div className="mb-8">
            <h2 className="text-2xl font-bold text-gray-900">Settings</h2>
            <p className="text-gray-600">Manage your account and notification preferences</p>
          </div>

          <form onSubmit={handleSubmit} className="space-y-6">
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
              <div className="lg:col-span-2 space-y-6">
                {/* Profile Section */}
                <div className="bg-white rounded-lg shadow-sm border">
                  <div className="p-6 border-b border-gray-200">
                    <div className="flex items-center space-x-2">
                      <User className="w-5 h-5 text-gray-400" />
                      <h3 className="text-lg font-medium text-gray-900">Profile Information</h3>
                    </div>
                  </div>
                  <div className="p-6 space-y-4">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Full Name
                      </label>
                      <input
                        type="text"
                        value={formData.name}
                        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                      />
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 mb-1">
                        Email Address
                      </label>
                      <input
                        type="email"
                        value={formData.email}
                        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
                        className="w-full border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                      />
                    </div>
                  </div>
                </div>

                {/* Notification Preferences */}
                <div className="bg-white rounded-lg shadow-sm border">
                  <div className="p-6 border-b border-gray-200">
                    <div className="flex items-center space-x-2">
                      <Bell className="w-5 h-5 text-gray-400" />
                      <h3 className="text-lg font-medium text-gray-900">Notification Preferences</h3>
                    </div>
                    <p className="mt-1 text-sm text-gray-500">
                      Choose how you want to receive notifications about API changes and issues.
                    </p>
                  </div>
                  <div className="p-6 space-y-4">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-3">
                        <Globe className="w-5 h-5 text-blue-500" />
                        <div>
                          <p className="text-sm font-medium text-gray-900">In-App Notifications</p>
                          <p className="text-sm text-gray-500">Receive notifications within the application</p>
                        </div>
                      </div>
                      <button
                        type="button"
                        onClick={() => handleNotificationChange('inApp')}
                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                          formData.notificationPreferences.inApp ? 'bg-blue-600' : 'bg-gray-200'
                        }`}
                      >
                        <span
                          className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                            formData.notificationPreferences.inApp ? 'translate-x-6' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>

                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-3">
                        <Mail className="w-5 h-5 text-green-500" />
                        <div>
                          <p className="text-sm font-medium text-gray-900">Email Notifications</p>
                          <p className="text-sm text-gray-500">Receive notifications via email</p>
                        </div>
                      </div>
                      <button
                        type="button"
                        onClick={() => handleNotificationChange('email')}
                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                          formData.notificationPreferences.email ? 'bg-blue-600' : 'bg-gray-200'
                        }`}
                      >
                        <span
                          className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                            formData.notificationPreferences.email ? 'translate-x-6' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>

                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-3">
                        <MessageSquare className="w-5 h-5 text-purple-500" />
                        <div>
                          <p className="text-sm font-medium text-gray-900">Slack Notifications</p>
                          <p className="text-sm text-gray-500">Receive notifications in Slack</p>
                        </div>
                      </div>
                      <button
                        type="button"
                        onClick={() => handleNotificationChange('slack')}
                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                          formData.notificationPreferences.slack ? 'bg-blue-600' : 'bg-gray-200'
                        }`}
                      >
                        <span
                          className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                            formData.notificationPreferences.slack ? 'translate-x-6' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>

                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-3">
                        <Webhook className="w-5 h-5 text-orange-500" />
                        <div>
                          <p className="text-sm font-medium text-gray-900">Webhook Notifications</p>
                          <p className="text-sm text-gray-500">Send notifications to custom webhooks</p>
                        </div>
                      </div>
                      <button
                        type="button"
                        onClick={() => handleNotificationChange('webhook')}
                        className={`relative inline-flex h-6 w-11 items-center rounded-full transition-colors ${
                          formData.notificationPreferences.webhook ? 'bg-blue-600' : 'bg-gray-200'
                        }`}
                      >
                        <span
                          className={`inline-block h-4 w-4 transform rounded-full bg-white transition-transform ${
                            formData.notificationPreferences.webhook ? 'translate-x-6' : 'translate-x-1'
                          }`}
                        />
                      </button>
                    </div>
                  </div>
                </div>
              </div>

              {/* Sidebar */}
              <div className="space-y-6">
                <div className="bg-white rounded-lg shadow-sm border p-6">
                  <div className="flex items-center space-x-2 mb-4">
                    <Shield className="w-5 h-5 text-gray-400" />
                    <h3 className="text-lg font-medium text-gray-900">Account Security</h3>
                  </div>
                  <div className="space-y-3">
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-700">API Key</span>
                      <span className="text-xs font-mono bg-gray-100 px-2 py-1 rounded">
                        {user?.api_key ? `${user.api_key.substring(0, 8)}...` : 'Not set'}
                      </span>
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-700">Plan</span>
                      <span className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                        {user?.plan || 'Free'}
                      </span>
                    </div>
                    <div className="flex items-center justify-between">
                      <span className="text-sm text-gray-700">API Quota</span>
                      <span className="text-xs text-gray-600">
                        {user?.apiQuota?.current || 0}/{user?.apiQuota?.limit || 0}
                      </span>
                    </div>
                  </div>
                </div>

                <button
                  type="submit"
                  disabled={updatePreferencesMutation.isPending}
                  className="w-full flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
                >
                  <Save className="w-4 h-4 mr-2" />
                  {updatePreferencesMutation.isPending ? 'Saving...' : 'Save Changes'}
                </button>
              </div>
            </div>
          </form>
        </div>
      </Layout>
    </RouteGuard>
  );
};

export default SettingsPage;

// End of Frontend Implementation
# APILens VSCode Extension
## Main Extension Entry Point (extension.ts)

```typescript
import * as vscode from 'vscode';
import { APIService } from './services/APIService';
import { WebSocketService } from './services/WebSocketService';
import { APILensWebviewProvider } from './providers/WebviewProvider';
import { APIDetailViewProvider } from './providers/APIDetailViewProvider';
import { StatusBarService } from './services/StatusBarService';
import { FileContextMenuHandler } from './handlers/FileContextMenuHandler';
import { FileSystemService } from './services/FileSystemService';
import { router } from './lib/router';

let apiService: APIService;
let webSocketService: WebSocketService;
let webviewProvider: APILensWebviewProvider;
let apiDetailProvider: APIDetailViewProvider;
let statusBarService: StatusBarService;
let fileContextHandler: FileContextMenuHandler;
let fileSystemService: FileSystemService;

export async function activate(context: vscode.ExtensionContext) {
    try {
        apiService = new APIService();
        webSocketService = new WebSocketService(context, apiService);
        fileSystemService = new FileSystemService(context, apiService);
        statusBarService = new StatusBarService(context, apiService);

        webviewProvider = new APILensWebviewProvider(context, apiService);
        apiDetailProvider = new APIDetailViewProvider(context, apiService);

        fileContextHandler = new FileContextMenuHandler(context, fileSystemService, apiService);
        const mainWebviewProvider = vscode.window.registerWebviewViewProvider(
            APILensWebviewProvider.viewType,
            webviewProvider,
            {
                webviewOptions: {
                    retainContextWhenHidden: true
                }
            }
        );

        const detailWebviewProvider = vscode.window.registerWebviewViewProvider(
            APIDetailViewProvider.viewType,
            apiDetailProvider,
            {
                webviewOptions: {
                    retainContextWhenHidden: true
                }
            }
        );

        const openPanelCommand = vscode.commands.registerCommand('apilens.openPanel', () => {
            webviewProvider.show();
        });

        const refreshDataCommand = vscode.commands.registerCommand('apilens.refreshData', async () => {
            webviewProvider.refresh();
            await statusBarService.refresh();
        });

        const addApiCommand = vscode.commands.registerCommand('apilens.addApi', async () => {
            webviewProvider.navigateTo('/add-api');
            webviewProvider.show();
        });

        const viewAnalyticsCommand = vscode.commands.registerCommand('apilens.viewAnalytics', () => {
            webviewProvider.navigateTo('/analytics');
            webviewProvider.show();
        });

        const viewNotificationsCommand = vscode.commands.registerCommand('apilens.viewNotifications', () => {
            webviewProvider.navigateTo('/notifications');
            webviewProvider.show();
        });

        const viewChangesCommand = vscode.commands.registerCommand('apilens.viewChanges', () => {
            webviewProvider.navigateTo('/changes');
            webviewProvider.show();
        });

        const showApiDetailCommand = vscode.commands.registerCommand('apilens.showApiDetail', (apiId: string) => {
            apiDetailProvider.showApiDetail(apiId);
        });

        const viewIssuesCommand = vscode.commands.registerCommand('apilens.viewIssues', () => {
            webviewProvider.navigateTo('/issues');
            webviewProvider.show();
        });

        const viewSettingsCommand = vscode.commands.registerCommand('apilens.viewSettings', () => {
            webviewProvider.navigateTo('/settings');
            webviewProvider.show();
        });

        // Add disposables
        context.subscriptions.push(
            mainWebviewProvider,
            detailWebviewProvider,
            openPanelCommand,
            refreshDataCommand,
            addApiCommand,
            viewAnalyticsCommand,
            viewNotificationsCommand,
            viewChangesCommand,
            showApiDetailCommand,
            viewIssuesCommand,
            viewSettingsCommand,
            statusBarService,
            webSocketService,
            fileSystemService
        );

        await webSocketService.connect();
        fileSystemService.startWatching();
        await statusBarService.show();

        // Check authentication
        const isAuthenticated = await apiService.isAuthenticated();
        if (!isAuthenticated) {
            vscode.window.showInformationMessage(
                'Welcome to APILens! Please authenticate to access all features.',
                'Open APILens'
            ).then(selection => {
                if (selection === 'Open APILens') {
                    vscode.commands.executeCommand('apilens.openPanel');
                }
            });
        }

        vscode.commands.executeCommand('setContext', 'apilens.hasApis', true);

    } catch (error) {
        vscode.window.showErrorMessage(`Failed to activate APILens: ${error}`);
    }
}

export function deactivate() {
    // Clean up services
    if (webSocketService) {
        webSocketService.disconnect();
    }
    
    if (statusBarService) {
        statusBarService.dispose();
    }

    if (fileSystemService) {
        fileSystemService.dispose();
    }

    router.dispose();
}
```

## API Service (services/APIService.ts)

```typescript
import axios, { AxiosInstance, AxiosResponse } from 'axios';
import * as vscode from 'vscode';

export interface ApiData {
    id: string;
    _id?: string;
    apiName: string;
    name?: string;
    description?: string;
    url?: string;
    openApiUrl?: string;
    version: string;
    type: 'openapi' | 'rest' | 'graphql' | 'soap';
    status?: 'active' | 'inactive' | 'deprecated';
    isActive: boolean;
    healthStatus: 'healthy' | 'unhealthy' | 'warning' | 'checking' | 'error' | 'degraded';
    lastChecked?: string;
    endpoints?: Endpoint[];
    tags?: string[];
    specification?: any;
    filePath?: string;
    specUrl?: string;
    createdAt?: string;
    updatedAt?: string;
}

export interface Endpoint {
    id: string;
    path: string;
    method: string;
    summary?: string;
    description?: string;
    parameters?: Parameter[];
    responses?: ApiResponse[];
}

export interface Parameter {
    name: string;
    in: 'query' | 'path' | 'header' | 'body';
    type: string;
    required: boolean;
    description?: string;
}

export interface ApiResponse {
    status: number;
    description: string;
    schema?: any;
}

export interface ChangeLog {
    id: string;
    _id?: string;
    apiId: string;
    version: string;
    changeType: 'added' | 'modified' | 'removed' | 'breaking' | 'deprecated';
    changes: Change[];
    timestamp: string;
    detectedAt: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    description?: string;
}

export interface Change {
    type: 'added' | 'modified' | 'removed';
    path: string;
    description: string;
    oldValue?: any;
    newValue?: any;
}

export interface Notification {
    id: string;
    _id?: string;
    title: string;
    message: string;
    content?: string;
    type: 'info' | 'warning' | 'error' | 'success' | 'alert';
    priority: 'low' | 'medium' | 'high' | 'critical';
    timestamp: string;
    createdAt: string;
    apiId?: string;
    isRead: boolean;
    read?: boolean;
    actions?: NotificationAction[];
    details?: any;
}

export interface NotificationAction {
    label: string;
    command: string;
    args?: any[];
}

export interface DashboardStats {
    totalApis: number;
    activeApis: number;
    inactiveApis: number;
    healthyApis: number;
    warningApis: number;
    errorApis: number;
    totalChanges: number;
    recentChanges: number;
    criticalIssues: number;
    unreadNotifications: number;
}

export interface Analytics {
    totalApis: number;
    healthyApis: number;
    warningApis: number;
    errorApis: number;
    totalChanges: number;
    recentChanges: ChangeLog[];
    popularApis: ApiData[];
    changesByType: { [key: string]: number };
    healthOverTime: { [key: string]: number };
    performanceMetrics: {
        averageResponseTime: number;
        uptime: number;
        errorRate: number;
    };
}

export class APIService {
    private client: AxiosInstance;
    private baseURL: string;
    private context?: vscode.ExtensionContext;
    private _onDataChanged = new vscode.EventEmitter<void>();
    public readonly onDataChanged = this._onDataChanged.event;

    constructor() {
        const config = vscode.workspace.getConfiguration('apilens');
        this.baseURL = config.get<string>('apiUrl', 'http://localhost:3000');
        
        this.client = axios.create({
            baseURL: this.baseURL,
            timeout: 10000,
            withCredentials: true,
            headers: {
                'Content-Type': 'application/json'
            }
        });

        this.setupInterceptors();
    }

    setContext(context: vscode.ExtensionContext) {
        this.context = context;
    }

    private setupInterceptors() {
        // Request interceptor
        this.client.interceptors.request.use(
            (config) => {
                return config;
            },
            (error) => {
                return Promise.reject(error);
            }
        );

        // Response interceptor
        this.client.interceptors.response.use(
            (response) => {
                return response;
            },
            (error) => {
                if (error.response?.status === 401) {
                    vscode.window.showErrorMessage('Authentication required. Please log in to APILens.');
                } else if (error.response?.status >= 500) {
                    vscode.window.showErrorMessage('Server error. Please try again later.');
                }
                return Promise.reject(error);
            }
        );
    }

    async isAuthenticated(): Promise<boolean> {
        try {
            const response = await this.client.get('/auth/status');
            return response.data.authenticated || response.data.isAuthenticated;
        } catch (error) {
            return false;
        }
    }

    async login(email: string, password: string): Promise<{ success: boolean; message: string }> {
        try {
            const response = await this.client.post('/auth/login', { email, password });
            
            if (response.data.success) {
                this._onDataChanged.fire();
                return { success: true, message: 'Login successful' };
            } else {
                return { success: false, message: response.data.message || 'Login failed' };
            }
        } catch (error: any) {
            return { 
                success: false, 
                message: error.response?.data?.message || 'Login failed' 
            };
        }
    }

    async logout(): Promise<void> {
        try {
            await this.client.post('/auth/logout');
            this._onDataChanged.fire();
        }
    }

    async getDashboardStats(): Promise<DashboardStats> {
        try {
            const response: AxiosResponse<DashboardStats> = await this.client.get('/dashboard/stats');
            return response.data;
        } catch (error) {
            throw new Error('Failed to fetch dashboard stats');
        }
    }

    async getApis(params?: any): Promise<ApiData[]> {
        try {
            const queryParams = new URLSearchParams(params).toString();
            const url = queryParams ? `/apis?${queryParams}` : '/apis';
            const response: AxiosResponse<ApiData[]> = await this.client.get(url);
            return response.data;
        } catch (error) {
            throw new Error('Failed to fetch APIs');
        }
    }

    async getApi(id: string): Promise<ApiData> {
        try {
            const response: AxiosResponse<ApiData> = await this.client.get(`/apis/${id}`);
            return response.data;
        } catch (error) {
            console.error(`VS Code Extension: Failed to fetch API ${id}:`, error);
            throw new Error(`Failed to fetch API ${id}`);
        }
    }

    async createApi(api: Partial<ApiData>): Promise<ApiData> {
        try {
            const response: AxiosResponse<ApiData> = await this.client.post('/apis', api);
            this._onDataChanged.fire();
            return response.data;
        } catch (error) {
            console.error('VS Code Extension: Failed to create API:', error);
            throw new Error('Failed to create API');
        }
    }

    async updateApi(id: string, api: Partial<ApiData>): Promise<ApiData> {
        try {
            const response: AxiosResponse<ApiData> = await this.client.put(`/apis/${id}`, api);
            this._onDataChanged.fire();
            return response.data;
        } catch (error) {
            console.error(`VS Code Extension: Failed to update API ${id}:`, error);
            throw new Error(`Failed to update API ${id}`);
        }
    }

    async deleteApi(id: string): Promise<void> {
        try {
            await this.client.delete(`/apis/${id}`);
            this._onDataChanged.fire();
        } catch (error) {
            console.error(`VS Code Extension: Failed to delete API ${id}:`, error);
            throw new Error(`Failed to delete API ${id}`);
        }
    }

    async toggleApiStatus(id: string): Promise<void> {
        try {
            await this.client.post(`/apis/${id}/toggle-status`);
            this._onDataChanged.fire();
        } catch (error) {
            console.error(`VS Code Extension: Failed to toggle API status ${id}:`, error);
            throw new Error(`Failed to toggle API status ${id}`);
        }
    }

    async checkApiNow(id: string): Promise<void> {
        try {
            await this.client.post(`/apis/${id}/check`);
            this._onDataChanged.fire();
        } catch (error) {
            console.error(`VS Code Extension: Failed to check API ${id}:`, error);
            throw new Error(`Failed to check API ${id}`);
        }
    }

    async testOpenApiUrl(url: string): Promise<{ valid: boolean; info?: any; error?: string }> {
        try {
            const response = await this.client.post('/apis/test-url', { url });
            return response.data;
        } catch (error: any) {
            return {
                valid: false,
                error: error.response?.data?.message || 'Failed to test URL'
            };
        }
    }

    async getChangelogs(params?: { apiId?: string; limit?: number }): Promise<ChangeLog[]> {
        try {
            const queryParams = new URLSearchParams(params as any).toString();
            const url = queryParams ? `/changelogs?${queryParams}` : '/changelogs';
            const response: AxiosResponse<ChangeLog[]> = await this.client.get(url);
            return response.data;
        } catch (error) {
            console.error('VS Code Extension: Failed to fetch changelogs:', error);
            throw new Error('Failed to fetch changelogs');
        }
    }

    async getNotifications(params?: { unreadOnly?: boolean }): Promise<Notification[]> {
        try {
            const queryParams = new URLSearchParams(params as any).toString();
            const url = queryParams ? `/notifications?${queryParams}` : '/notifications';
            const response: AxiosResponse<Notification[]> = await this.client.get(url);
            return response.data;
        } catch (error) {
            console.error('VS Code Extension: Failed to fetch notifications:', error);
            throw new Error('Failed to fetch notifications');
        }
    }

    async markNotificationAsRead(id: string): Promise<void> {
        try {
            await this.client.patch(`/notifications/${id}/read`);
            this._onDataChanged.fire();
        } catch (error) {
            console.error(`VS Code Extension: Failed to mark notification ${id} as read:`, error);
        }
    }

    async markAllNotificationsAsRead(): Promise<void> {
        try {
            await this.client.patch('/notifications/mark-all-read');
            this._onDataChanged.fire();
        } catch (error) {
            console.error('VS Code Extension: Failed to mark all notifications as read:', error);
        }
    }

    async getAnalytics(params?: any): Promise<Analytics> {
        try {
            const queryParams = new URLSearchParams(params).toString();
            const url = queryParams ? `/analytics?${queryParams}` : '/analytics';
            const response: AxiosResponse<Analytics> = await this.client.get(url);
            return response.data;
        } catch (error) {
            console.error('VS Code Extension: Failed to fetch analytics:', error);
            throw new Error('Failed to fetch analytics');
        }
    }

    async updateUserSettings(settings: any): Promise<void> {
        try {
            await this.client.put('/user/settings', settings);
            this._onDataChanged.fire();
        } catch (error) {
            console.error('VS Code Extension: Failed to update settings:', error);
            throw new Error('Failed to update settings');
        }
    }

    async importOpenAPISpec(spec: any, name: string, description?: string): Promise<ApiData> {
        try {
            const response: AxiosResponse<ApiData> = await this.client.post('/apis/import', {
                spec,
                name,
                description
            });
            this._onDataChanged.fire();
            return response.data;
        } catch (error) {
            console.error('VS Code Extension: Failed to import OpenAPI spec:', error);
            throw new Error('Failed to import OpenAPI spec');
        }
    }

    async validateOpenAPISpec(spec: any): Promise<{ valid: boolean; errors?: string[] }> {
        try {
            const response = await this.client.post('/apis/validate', { spec });
            return response.data;
        } catch (error) {
            console.error('VS Code Extension: Failed to validate OpenAPI spec:', error);
            throw new Error('Failed to validate OpenAPI spec');
        }
    }

    public refreshData(): void {
        this._onDataChanged.fire();
    }

    public dispose(): void {
        this._onDataChanged.dispose();
    }
}
```

## WebView Provider (providers/WebviewProvider.ts)

```typescript
import * as vscode from 'vscode';
import { APIService, ApiData, DashboardStats } from '../services/APIService';
import { router, RouteParams } from '../lib/router';

export class APILensWebviewProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'apilens.main';
    private _view?: vscode.WebviewView;

    constructor(
        private readonly context: vscode.ExtensionContext,
        private readonly apiService: APIService
    ) {
        this.apiService.setContext(context);
        router.onRouteChange((route, params) => {
            this.handleRouteChange(route, params);
        });
    }

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this.context.extensionUri]
        };

        webviewView.webview.html = this.getHtmlForWebview();

        webviewView.webview.onDidReceiveMessage(
            async (message) => {
                await this.handleMessage(message);
            },
            undefined,
            this.context.subscriptions
        );

        setTimeout(() => {
            this.checkAuthAndNavigate();
        }, 100);
    }

    public show() {
        if (this._view) {
            this._view.show(true);
        }
    }

    public refresh() {
        this.handleGetDashboard().catch(() => {});
    }

    public navigateTo(path: string) {
        router.navigate(path);
    }

    private handleRouteChange(route: string, params: RouteParams) {
        this.sendMessage({ type: 'routeChanged', route, params });
    }

    private sendMessage(message: any) {
        if (this._view) {
            this._view.webview.postMessage(message);
        }
    }

    private async checkAuthAndNavigate() {
        try {
            const isAuthenticated = await this.apiService.isAuthenticated();
            
            if (isAuthenticated) {
                this.sendMessage({ type: 'authStatus', data: { isAuthenticated: true } });
                this.handleGetDashboard();
            } else {
                this.sendMessage({ type: 'authStatus', data: { isAuthenticated: false } });
            }
        } catch (error) {
            this.sendMessage({ type: 'authStatus', data: { isAuthenticated: false } });
        }
    }

    private async handleMessage(message: any) {
        switch (message.type) {
            case 'login':
                await this.handleLogin(message.data);
                break;
            case 'logout':
                await this.handleLogout();
                break;
            case 'getDashboard':
                await this.handleGetDashboard();
                break;
            case 'getDashboardStats':
                await this.handleGetDashboardStats();
                break;
            case 'getApis':
                await this.handleGetApis(message.params);
                break;
            case 'createApi':
                await this.handleCreateApi(message.data);
                break;
            case 'testOpenApiUrl':
                await this.handleTestOpenApiUrl(message.url);
                break;
            case 'toggleApiStatus':
                await this.handleToggleApiStatus(message.id);
                break;
            case 'deleteApi':
                await this.handleDeleteApi(message.id);
                break;
            case 'checkApiNow':
                await this.handleCheckApiNow(message.id);
                break;
            case 'getAnalytics':
                await this.handleGetAnalytics(message.params);
                break;
            case 'getNotifications':
                await this.handleGetNotifications(message.params);
                break;
            case 'markNotificationRead':
                await this.handleMarkNotificationRead(message.id);
                break;
            case 'markAllNotificationsRead':
                await this.handleMarkAllNotificationsRead();
                break;
            case 'deleteNotification':
                await this.handleDeleteNotification(message.id);
                break;
            case 'getChangelogs':
                await this.handleGetChangelogs(message.params);
                break;
            case 'getIssues':
                await this.handleGetIssues();
                break;
            case 'updateSettings':
                await this.handleUpdateSettings(message.data);
                break;
            case 'navigate':
                router.navigate(message.path);
                break;
        }
    }

    private async handleLogin(credentials: { email: string; password: string }) {
        try {
            await this.apiService.login(credentials.email, credentials.password);
            this.sendMessage({ 
                type: 'loginResponse', 
                data: { success: true } 
            });
            this.sendMessage({ type: 'authStatus', data: { isAuthenticated: true } });
            this.handleGetDashboard();
        } catch (error: any) {
            this.sendMessage({ 
                type: 'loginResponse', 
                data: { 
                    success: false, 
                    error: error.message || 'Login failed' 
                }
            });
        }
    }

    private async handleLogout() {
        try {
            await this.apiService.logout();
            this.sendMessage({ type: 'logoutSuccess' });
            this.sendMessage({ type: 'authStatus', data: { isAuthenticated: false } });
            router.navigate('/login');
        } catch (error: any) {
            this.sendMessage({ 
                type: 'logoutError', 
                error: error.message 
            });
        }
    }

    private async handleGetDashboard() {
        try {
            const [stats, apis] = await Promise.all([
                this.apiService.getDashboardStats(),
                this.apiService.getApis()
            ]);
            
            this.sendMessage({ 
                type: 'dashboardData', 
                data: { stats, apis } 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleGetDashboardStats() {
        try {
            const stats = await this.apiService.getDashboardStats();
            this.sendMessage({ 
                type: 'dashboardStats', 
                data: stats 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleGetApis(params: any) {
        try {
            const apis = await this.apiService.getApis(params);
            this.sendMessage({ 
                type: 'apisData', 
                data: apis 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleCreateApi(data: any) {
        try {
            const api = await this.apiService.createApi(data);
            this.sendMessage({ 
                type: 'apiCreated', 
                data: api 
            });
            await this.handleGetApis({});
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleTestOpenApiUrl(url: string) {
        try {
            const result = await this.apiService.testOpenApiUrl(url);
            this.sendMessage({ 
                type: 'openApiUrlTestResult', 
                data: result 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'openApiUrlTestResult', 
                data: { 
                    valid: false, 
                    error: error.message 
                } 
            });
        }
    }

    private async handleToggleApiStatus(id: string) {
        try {
            await this.apiService.toggleApiStatus(id);
            this.sendMessage({ type: 'apiStatusToggled', id });
            await this.handleGetApis({});
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleDeleteApi(id: string) {
        try {
            await this.apiService.deleteApi(id);
            this.sendMessage({ type: 'apiDeleted', id });
            await this.handleGetApis({});
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleCheckApiNow(id: string) {
        try {
            await this.apiService.checkApiNow(id);
            this.sendMessage({ type: 'apiChecked', id });
            vscode.window.showInformationMessage('API check initiated successfully!');
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleGetAnalytics(params: any) {
        try {
            const analytics = await this.apiService.getAnalytics(params);
            this.sendMessage({ 
                type: 'analyticsData', 
                data: analytics 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleGetNotifications(params: any) {
        try {
            const notifications = await this.apiService.getNotifications(params);
            this.sendMessage({ 
                type: 'notificationsData', 
                data: notifications 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleMarkNotificationRead(id: string) {
        try {
            await this.apiService.markNotificationAsRead(id);
            await this.handleGetNotifications({});
        } catch (error: any) {
            this.sendMessage({ type: 'error', error: error.message });
        }
    }

    private async handleMarkAllNotificationsRead() {
        try {
            await this.apiService.markAllNotificationsAsRead();
            await this.handleGetNotifications({});
        } catch (error: any) {
            this.sendMessage({ type: 'error', error: error.message });
        }
    }

    private async handleDeleteNotification(id: string) {
        try {
            await this.apiService.markNotificationAsRead(id);
            await this.handleGetNotifications({});
        } catch (error: any) {
            this.sendMessage({ type: 'error', error: error.message });
        }
    }

    private async handleGetChangelogs(params: any) {
        try {
            const changelogs = await this.apiService.getChangelogs(params);
            this.sendMessage({ 
                type: 'changelogsData', 
                data: changelogs 
            });
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    private async handleGetIssues() {
        try {
            console.log('VS Code Extension: Getting issues data...');
            const [apis, notifications] = await Promise.all([
                this.apiService.getApis({}),
                this.apiService.getNotifications({ unreadOnly: false })
            ]);
            
            const healthIssues = (apis || []).filter((api: any) => {
                const status = (api.healthStatus || '').toLowerCase();
                return ['unhealthy', 'error', 'warning', 'degraded'].includes(status);
            }).map((api: any, index: number) => ({
                id: `health-${api._id || api.id}-${index}`,
                apiId: api._id || api.id,
                priority: api.healthStatus === 'unhealthy' ? 'critical' : 'medium',
                type: 'health',
                title: `Health Issue: ${api.apiName || api.name || 'Unknown API'}`,
                description: `API health check failed. Status: ${api.healthStatus}`,
                createdAt: api.lastChecked || new Date().toISOString(),
                isRead: false,
                details: {
                    apiName: api.apiName || api.name,
                    healthStatus: api.healthStatus,
                    lastChecked: api.lastChecked,
                    url: api.openApiUrl || api.url
                }
            }));

            const alertNotifications = (notifications || [])
                .filter((notif: any) => ['critical', 'high', 'medium'].includes(notif.priority))
                .map((notif: any) => ({
                    id: notif._id || notif.id || `notif-${Math.random().toString(36).substr(2, 9)}`,
                    apiId: notif.apiId,
                    priority: notif.priority || 'medium',
                    type: notif.type || 'alert',
                    title: notif.title || notif.message || 'API Alert',
                    description: notif.content || notif.description || '',
                    createdAt: notif.createdAt || new Date().toISOString(),
                    isRead: notif.isRead || false,
                    details: notif.details
                }));

            const allIssues = [...healthIssues, ...alertNotifications];
            
            this.sendMessage({ type: 'issuesData', data: allIssues });
        } catch (error: any) {
            console.error('VS Code Extension: Error getting issues:', error);
            this.sendMessage({ type: 'error', error: error.message });
        }
    }

    private async handleUpdateSettings(data: any) {
        try {
            await this.apiService.updateUserSettings(data);
            this.sendMessage({ type: 'settingsUpdated' });
            vscode.window.showInformationMessage('Settings updated successfully!');
        } catch (error: any) {
            this.sendMessage({ 
                type: 'error', 
                error: error.message 
            });
        }
    }

    // Complete WebView HTML with full featured UI
    private getHtmlForWebview(): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APILens</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: var(--vscode-font-family);
            font-size: var(--vscode-font-size);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            height: 100vh;
            overflow: hidden;
        }
        
        /* Complete styling for comprehensive UI */
        /* [Full CSS implementation continues...] */
    </style>
</head>
<body>
    <div id="app">
        <!-- Full application structure with routing -->
    </div>
    
    <script>
        const vscode = acquireVsCodeApi();
    
    </script>
</body>
</html>`;
    }
}
```

## File Context Menu Handler (handlers/FileContextMenuHandler.ts)

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { FileSystemService } from '../services/FileSystemService';
import { APIService } from '../services/APIService';

export class FileContextMenuHandler {
    constructor(
        private readonly context: vscode.ExtensionContext,
        private readonly fileSystemService: FileSystemService,
        private readonly apiService: APIService
    ) {
        this.registerCommands();
    }

    private registerCommands() {
        const registerApiCommand = vscode.commands.registerCommand(
            'apilens.registerApiFromFile',
            async (uri: vscode.Uri) => {
                await this.registerApiFromFile(uri);
            }
        );

        const importApiCommand = vscode.commands.registerCommand(
            'apilens.importApiSpec',
            async (uri: vscode.Uri) => {
                await this.importApiSpec(uri);
            }
        );

        const validateCommand = vscode.commands.registerCommand(
            'apilens.validateOpenAPI',
            async (uri: vscode.Uri) => {
                await this.validateOpenAPISpec(uri);
            }
        );

        this.context.subscriptions.push(registerApiCommand, importApiCommand, validateCommand);
    }

    private async registerApiFromFile(uri: vscode.Uri) {
        try {
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Registering API from file...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 20, message: 'Reading file...' });

                const content = await vscode.workspace.fs.readFile(uri);
                const fileContent = Buffer.from(content).toString('utf8');

                progress.report({ increment: 40, message: 'Parsing OpenAPI spec...' });

                let spec;
                try {
                    spec = JSON.parse(fileContent);
                } catch {
                    try {
                        const yaml = require('js-yaml');
                        spec = yaml.load(fileContent);
                    } catch {
                        throw new Error('Invalid JSON/YAML format');
                    }
                }

                progress.report({ increment: 60, message: 'Validating specification...' });

                if (!spec.openapi && !spec.swagger) {
                    throw new Error('Not a valid OpenAPI/Swagger specification');
                }

                const apiData = {
                    apiName: spec.info?.title || path.basename(uri.fsPath, path.extname(uri.fsPath)),
                    description: spec.info?.description || '',
                    version: spec.info?.version || '1.0.0',
                    type: 'openapi' as const,
                    url: this.extractBaseUrl(spec),
                    tags: spec.tags?.map((tag: any) => tag.name) || [],
                    specification: spec
                };

                progress.report({ increment: 80, message: 'Creating API...' });

                await this.apiService.createApi(apiData);

                progress.report({ increment: 100, message: 'Complete!' });

                vscode.window.showInformationMessage(
                    `API "${apiData.apiName}" registered successfully!`,
                    'View API'
                ).then(selection => {
                    if (selection === 'View API') {
                        vscode.commands.executeCommand('apilens.openPanel');
                    }
                });
            });

        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to register API: ${error.message}`);
        }
    }

    private async importApiSpec(uri: vscode.Uri) {
        try {
            const options: vscode.QuickPickItem[] = [
                {
                    label: 'Create New API',
                    description: 'Register this spec as a new API in APILens'
                },
                {
                    label: 'Update Existing API',
                    description: 'Update an existing API with this specification'
                },
                {
                    label: 'Preview Only',
                    description: 'Just preview the API specification'
                }
            ];

            const selection = await vscode.window.showQuickPick(options, {
                placeHolder: 'How would you like to import this API specification?'
            });

            if (!selection) return;

            switch (selection.label) {
                case 'Create New API':
                    await this.registerApiFromFile(uri);
                    break;
                case 'Update Existing API':
                    await this.updateExistingApi(uri);
                    break;
                case 'Preview Only':
                    await this.previewApiSpec(uri);
                    break;
            }

        } catch (error: any) {
            vscode.window.showErrorMessage(`Import failed: ${error.message}`);
        }
    }

    private async updateExistingApi(uri: vscode.Uri) {
        try {
            const apis = await this.apiService.getApis();
            
            const apiOptions = apis.map(api => ({
                label: api.apiName,
                description: api.description,
                detail: `Version: ${api.version} | Type: ${api.type}`,
                apiId: api.id
            }));

            if (apiOptions.length === 0) {
                vscode.window.showInformationMessage('No existing APIs to update. Creating new API instead...');
                await this.registerApiFromFile(uri);
                return;
            }

            const selectedApi = await vscode.window.showQuickPick(apiOptions, {
                placeHolder: 'Select API to update'
            });

            if (!selectedApi) return;

            const content = await vscode.workspace.fs.readFile(uri);
            const fileContent = Buffer.from(content).toString('utf8');
            
            let spec;
            try {
                spec = JSON.parse(fileContent);
            } catch {
                const yaml = require('js-yaml');
                spec = yaml.load(fileContent);
            }

            const updateData = {
                version: spec.info?.version || '1.0.0',
                description: spec.info?.description || '',
                specification: spec
            };

            await this.apiService.updateApi(selectedApi.apiId, updateData);
            
            vscode.window.showInformationMessage(`API "${selectedApi.label}" updated successfully!`);

        } catch (error: any) {
            vscode.window.showErrorMessage(`Update failed: ${error.message}`);
        }
    }

    private async previewApiSpec(uri: vscode.Uri) {
        try {
            const content = await vscode.workspace.fs.readFile(uri);
            const fileContent = Buffer.from(content).toString('utf8');
            
            let spec;
            try {
                spec = JSON.parse(fileContent);
            } catch {
                const yaml = require('js-yaml');
                spec = yaml.load(fileContent);
            }

            const panel = vscode.window.createWebviewPanel(
                'apiPreview',
                `API Preview: ${spec.info?.title || 'Unknown'}`,
                vscode.ViewColumn.One,
                { enableScripts: true }
            );

            panel.webview.html = this.getPreviewHtml(spec);

        } catch (error: any) {
            vscode.window.showErrorMessage(`Preview failed: ${error.message}`);
        }
    }

    private async validateOpenAPISpec(uri: vscode.Uri) {
        try {
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Validating OpenAPI specification...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 30, message: 'Reading file...' });

                const content = await vscode.workspace.fs.readFile(uri);
                const fileContent = Buffer.from(content).toString('utf8');

                progress.report({ increment: 60, message: 'Parsing and validating...' });

                const validation = await this.fileSystemService.validateOpenAPISpec(fileContent);

                progress.report({ increment: 100, message: 'Complete!' });

                if (validation.isValid) {
                    vscode.window.showInformationMessage(
                        '✅ Valid OpenAPI specification',
                        `API: ${validation.info?.title}, Version: ${validation.info?.version}`
                    );
                } else {
                    const errors = validation.errors?.join('\\n') || 'Unknown validation errors';
                    vscode.window.showErrorMessage(`❌ Invalid OpenAPI specification:\\n${errors}`);
                }
            });

        } catch (error: any) {
            vscode.window.showErrorMessage(`Validation failed: ${error.message}`);
        }
    }

    private extractBaseUrl(spec: any): string {
        if (spec.servers && spec.servers.length > 0) {
            return spec.servers[0].url;
        }
        
        if (spec.host) {
            const scheme = spec.schemes && spec.schemes.length > 0 ? spec.schemes[0] : 'https';
            const basePath = spec.basePath || '';
            return `${scheme}://${spec.host}${basePath}`;
        }
        
        return 'http://localhost:3000';
    }

    private getPreviewHtml(spec: any): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Preview</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            padding: 20px;
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
        }
        .header {
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 16px;
            margin-bottom: 20px;
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        .version {
            color: var(--vscode-descriptionForeground);
            font-size: 14px;
        }
        .description {
            margin-top: 12px;
            line-height: 1.6;
        }
        .section {
            margin: 20px 0;
        }
        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--vscode-textLink-foreground);
        }
        .endpoint {
            background: var(--vscode-editor-inactiveSelectionBackground);
            border: 1px solid var(--vscode-panel-border);
            border-radius: 4px;
            padding: 12px;
            margin-bottom: 8px;
        }
        .method {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }
        .method-get { background: #4CAF50; color: white; }
        .method-post { background: #2196F3; color: white; }
        .method-put { background: #FF9800; color: white; }
        .method-delete { background: #F44336; color: white; }
        .path {
            font-family: monospace;
            font-size: 14px;
        }
        .tags {
            margin-top: 8px;
        }
        .tag {
            display: inline-block;
            background: var(--vscode-badge-background);
            color: var(--vscode-badge-foreground);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            margin-right: 4px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">${spec.info?.title || 'API Specification'}</div>
        <div class="version">Version: ${spec.info?.version || 'Unknown'}</div>
        ${spec.info?.description ? `<div class="description">${spec.info.description}</div>` : ''}
    </div>
    
    ${spec.servers ? `
    <div class="section">
        <div class="section-title">Servers</div>
        ${spec.servers.map((server: any) => `
            <div>• ${server.url}${server.description ? ` - ${server.description}` : ''}</div>
        `).join('')}
    </div>
    ` : ''}
    
    ${spec.paths ? `
    <div class="section">
        <div class="section-title">Endpoints</div>
        ${Object.entries(spec.paths).map(([path, methods]: [string, any]) => 
            Object.entries(methods).map(([method, details]: [string, any]) => {
                if (typeof details !== 'object' || !details) return '';
                return `
                    <div class="endpoint">
                        <div>
                            <span class="method method-${method.toLowerCase()}">${method.toUpperCase()}</span>
                            <span class="path">${path}</span>
                        </div>
                        ${details.summary ? `<div style="margin-top: 8px; font-weight: 500;">${details.summary}</div>` : ''}
                        ${details.description ? `<div style="margin-top: 4px; color: var(--vscode-descriptionForeground); font-size: 13px;">${details.description}</div>` : ''}
                        ${details.tags ? `
                            <div class="tags">
                                ${details.tags.map((tag: string) => `<span class="tag">${tag}</span>`).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('')
        ).join('')}
    </div>
    ` : ''}
    
    ${spec.tags ? `
    <div class="section">
        <div class="section-title">Tags</div>
        ${spec.tags.map((tag: any) => `
            <div>• <strong>${tag.name}</strong>${tag.description ? ` - ${tag.description}` : ''}</div>
        `).join('')}
    </div>
    ` : ''}
</body>
</html>`;
    }
}
```

## File System Service (services/FileSystemService.ts)

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import { APIService } from './APIService';

export interface OpenAPIFile {
    path: string;
    name: string;
    content: string;
    apiId?: string;
}

export class FileSystemService {
    private context: vscode.ExtensionContext;
    private apiService: APIService;
    private watchers: vscode.FileSystemWatcher[] = [];

    constructor(context: vscode.ExtensionContext, apiService: APIService) {
        this.context = context;
        this.apiService = apiService;
    }

    async findOpenAPIFiles(): Promise<OpenAPIFile[]> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            return [];
        }

        const openApiFiles: OpenAPIFile[] = [];

        for (const folder of workspaceFolders) {
            const patterns = [
                '**/swagger.{json,yaml,yml}',
                '**/openapi.{json,yaml,yml}',
                '**/api-spec.{json,yaml,yml}',
                '**/*swagger*.{json,yaml,yml}',
                '**/*openapi*.{json,yaml,yml}',
                '**/*api-spec*.{json,yaml,yml}'
            ];

            for (const pattern of patterns) {
                const files = await vscode.workspace.findFiles(
                    new vscode.RelativePattern(folder, pattern),
                    '**/node_modules/**',
                    100
                );

                for (const file of files) {
                    try {
                        const content = await vscode.workspace.fs.readFile(file);
                        const textContent = Buffer.from(content).toString('utf8');
                        
                        if (this.isOpenAPISpec(textContent)) {
                            openApiFiles.push({
                                path: file.fsPath,
                                name: path.basename(file.fsPath),
                                content: textContent
                            });
                        }
                    } catch (error) {
                        console.error(`Error reading file ${file.fsPath}:`, error);
                    }
                }
            }
        }

        return openApiFiles;
    }

    private isOpenAPISpec(content: string): boolean {
        try {
            const parsed = JSON.parse(content);
            return !!(parsed.openapi || parsed.swagger);
        } catch {
            return content.includes('openapi:') || content.includes('swagger:');
        }
    }

    async watchOpenAPIFiles(onFileChange: (file: OpenAPIFile) => void): Promise<void> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders) {
            return;
        }

        this.watchers.forEach(watcher => watcher.dispose());
        this.watchers = [];

        for (const folder of workspaceFolders) {
            const watcher = vscode.workspace.createFileSystemWatcher(
                new vscode.RelativePattern(folder, '**/*.{json,yaml,yml}')
            );

            watcher.onDidChange(async (uri) => {
                await this.handleFileChange(uri, onFileChange);
            });

            watcher.onDidCreate(async (uri) => {
                await this.handleFileChange(uri, onFileChange);
            });

            this.watchers.push(watcher);
            this.context.subscriptions.push(watcher);
        }
    }

    private async handleFileChange(uri: vscode.Uri, onFileChange: (file: OpenAPIFile) => void): Promise<void> {
        try {
            const content = await vscode.workspace.fs.readFile(uri);
            const textContent = Buffer.from(content).toString('utf8');
            
            if (this.isOpenAPISpec(textContent)) {
                const file: OpenAPIFile = {
                    path: uri.fsPath,
                    name: path.basename(uri.fsPath),
                    content: textContent
                };
                
                onFileChange(file);
            }
        } catch (error) {
            console.error(`Error handling file change ${uri.fsPath}:`, error);
        }
    }

    async createAPIFromFile(file: OpenAPIFile): Promise<void> {
        try {
            let specData;
            try {
                specData = JSON.parse(file.content);
            } catch {
                vscode.window.showErrorMessage('YAML OpenAPI specs not yet supported. Please use JSON format.');
                return;
            }

            const apiData = {
                apiName: specData.info?.title || path.basename(file.name, path.extname(file.name)),
                description: specData.info?.description || '',
                version: specData.info?.version || '1.0.0',
                type: 'openapi',
                specUrl: vscode.Uri.file(file.path).toString(),
                url: this.extractServerUrl(specData),
                filePath: file.path
            };

            await this.apiService.createApi(apiData);
            
            vscode.window.showInformationMessage(
                `API "${apiData.apiName}" created from ${file.name}`,
                'View APIs'
            ).then((selection) => {
                if (selection === 'View APIs') {
                    vscode.commands.executeCommand('apilens.openPanel');
                }
            });

        } catch (error: any) {
            vscode.window.showErrorMessage(`Failed to create API from file: ${error.message}`);
        }
    }

    private extractServerUrl(specData: any): string {
        if (specData.servers && specData.servers.length > 0) {
            return specData.servers[0].url;
        }
        if (specData.host) {
            const scheme = specData.schemes?.[0] || 'https';
            const basePath = specData.basePath || '';
            return `${scheme}://${specData.host}${basePath}`;
        }
        return '';
    }

    async showFileQuickPick(): Promise<OpenAPIFile | undefined> {
        const files = await this.findOpenAPIFiles();
        
        if (files.length === 0) {
            vscode.window.showInformationMessage('No OpenAPI specification files found in workspace');
            return undefined;
        }

        const quickPickItems = files.map(file => ({
            label: file.name,
            description: path.dirname(file.path),
            detail: file.path,
            file: file
        }));

        const selected = await vscode.window.showQuickPick(quickPickItems, {
            placeHolder: 'Select OpenAPI specification file',
            matchOnDescription: true,
            matchOnDetail: true
        });

        return selected?.file;
    }

    startWatching(): void {
        this.watchOpenAPIFiles(() => {});
    }

    dispose(): void {
        this.watchers.forEach(watcher => watcher.dispose());
        this.watchers = [];
    }

    async validateOpenAPISpec(content: string): Promise<{
        isValid: boolean;
        errors?: string[];
        info?: { title: string; version: string; description?: string };
    }> {
        try {
            let spec;
            
            try {
                spec = JSON.parse(content);
            } catch {
                try {
                    const yaml = require('js-yaml');
                    spec = yaml.load(content);
                } catch (yamlError) {
                    return {
                        isValid: false,
                        errors: ['Invalid JSON/YAML format']
                    };
                }
            }

            const errors: string[] = [];

            if (!spec.openapi && !spec.swagger) {
                errors.push('Missing OpenAPI/Swagger version field');
            }

            if (!spec.info) {
                errors.push('Missing required "info" object');
            } else {
                if (!spec.info.title) {
                    errors.push('Missing required "info.title" field');
                }
                if (!spec.info.version) {
                    errors.push('Missing required "info.version" field');
                }
            }

            if (!spec.paths || Object.keys(spec.paths).length === 0) {
                errors.push('No API paths defined (this may be intentional for some specs)');
            }

            const isValid = errors.length === 0 || (errors.length === 1 && errors[0].includes('No API paths'));

            return {
                isValid,
                errors: errors.length > 0 ? errors : undefined,
                info: spec.info ? {
                    title: spec.info.title || 'Unknown',
                    version: spec.info.version || 'Unknown',
                    description: spec.info.description
                } : undefined
            };

        } catch (error: any) {
            return {
                isValid: false,
                errors: [`Validation error: ${error.message}`]
            };
        }
    }
}
```

## Status Bar Service (services/StatusBarService.ts)

```typescript
import * as vscode from 'vscode';
import { APIService } from './APIService';

export class StatusBarService {
    private statusBarItem: vscode.StatusBarItem;
    private context: vscode.ExtensionContext;
    private apiService: APIService;
    private updateInterval: any = null;

    constructor(context: vscode.ExtensionContext, apiService: APIService) {
        this.context = context;
        this.apiService = apiService;
        
        this.statusBarItem = vscode.window.createStatusBarItem(
            vscode.StatusBarAlignment.Right,
            100
        );
        
        this.statusBarItem.command = 'apilens.openPanel';
        this.statusBarItem.tooltip = 'Click to open APILens';
        
        context.subscriptions.push(this.statusBarItem);
    }

    async show(): Promise<void> {
        try {
            const isAuth = await this.apiService.isAuthenticated();
            if (!isAuth) {
                this.statusBarItem.text = '$(globe) APILens: Not logged in';
                this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.warningBackground');
                this.statusBarItem.show();
                return;
            }

            await this.updateStats();
            this.statusBarItem.show();
            
            this.startAutoUpdate();
            
        } catch (error) {
            this.statusBarItem.text = '$(globe) APILens: Error';
            this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.errorBackground');
            this.statusBarItem.show();
        }
    }

    hide(): void {
        this.statusBarItem.hide();
        this.stopAutoUpdate();
    }

    async updateStats(): Promise<void> {
        try {
            const stats = await this.apiService.getDashboardStats();
            
            const activeApis = stats.activeApis || 0;
            const totalApis = stats.totalApis || 0;
            const criticalIssues = stats.criticalIssues || 0;
            
            let text = `$(globe) APILens: ${activeApis}/${totalApis} APIs`;
            let backgroundColor: vscode.ThemeColor | undefined;
            
            if (criticalIssues > 0) {
                text += ` $(warning) ${criticalIssues}`;
                backgroundColor = new vscode.ThemeColor('statusBarItem.errorBackground');
            } else {
                backgroundColor = undefined;
            }
            
            this.statusBarItem.text = text;
            this.statusBarItem.backgroundColor = backgroundColor;
            
        } catch (error) {
            this.statusBarItem.text = '$(globe) APILens: Error';
            this.statusBarItem.backgroundColor = new vscode.ThemeColor('statusBarItem.errorBackground');
        }
    }

    private startAutoUpdate(): void {
        this.stopAutoUpdate();
        
        this.updateInterval = setInterval(async () => {
            await this.updateStats();
        }, 60000);
    }

    private stopAutoUpdate(): void {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }

    updateConnectionStatus(connected: boolean): void {
        if (connected) {
            this.statusBarItem.tooltip = 'APILens: Connected with real-time updates';
        } else {
            this.statusBarItem.tooltip = 'APILens: Connected (real-time unavailable)';
        }
    }

    async refresh(): Promise<void> {
        await this.updateStats();
    }

    dispose(): void {
        this.stopAutoUpdate();
        this.statusBarItem.dispose();
    }
}
```

## API Detail View Provider (providers/APIDetailViewProvider.ts)

```typescript
import * as vscode from 'vscode';
import { APIService } from '../services/APIService';

export class APIDetailViewProvider implements vscode.WebviewViewProvider {
    public static readonly viewType = 'apilens.apiDetail';
    private _view?: vscode.WebviewView;
    private currentApiId?: string;

    constructor(
        private readonly context: vscode.ExtensionContext,
        private readonly apiService: APIService
    ) {}

    public resolveWebviewView(
        webviewView: vscode.WebviewView,
        context: vscode.WebviewViewResolveContext,
        _token: vscode.CancellationToken,
    ) {
        this._view = webviewView;

        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [this.context.extensionUri]
        };

        webviewView.webview.html = this.getHtmlForWebview();

        webviewView.webview.onDidReceiveMessage(
            async (message) => {
                await this.handleMessage(message);
            },
            undefined,
            this.context.subscriptions
        );
    }

    public showApiDetail(apiId: string) {
        this.currentApiId = apiId;
        if (this._view) {
            this._view.show(true);
            this.loadApiDetail(apiId);
        }
    }

    private async loadApiDetail(apiId: string) {
        try {
            const api = await this.apiService.getApi(apiId);
            const changelogs = await this.apiService.getChangelogs({ apiId, limit: 10 });
            
            this.sendMessage({
                type: 'apiDetailData',
                data: {
                    api,
                    changelogs,
                    issues: []
                }
            });
        } catch (error: any) {
            this.sendMessage({
                type: 'error',
                error: error.message
            });
        }
    }

    private async handleMessage(message: any) {
        switch (message.type) {
            case 'refreshDetail':
                if (this.currentApiId) {
                    await this.loadApiDetail(this.currentApiId);
                }
                break;
            case 'checkApi':
                if (this.currentApiId) {
                    try {
                        await this.apiService.checkApiNow(this.currentApiId);
                        this.sendMessage({ type: 'apiChecked' });
                        setTimeout(() => this.loadApiDetail(this.currentApiId!), 2000);
                    } catch (error: any) {
                        this.sendMessage({ type: 'error', error: error.message });
                    }
                }
                break;
            case 'toggleStatus':
                if (this.currentApiId) {
                    try {
                        await this.apiService.toggleApiStatus(this.currentApiId);
                        this.sendMessage({ type: 'statusToggled' });
                        await this.loadApiDetail(this.currentApiId);
                    } catch (error: any) {
                        this.sendMessage({ type: 'error', error: error.message });
                    }
                }
                break;
        }
    }

    private sendMessage(message: any) {
        if (this._view) {
            this._view.webview.postMessage(message);
        }
    }

    private getHtmlForWebview(): string {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>API Detail</title>
    <style>
        body {
            font-family: var(--vscode-font-family);
            font-size: var(--vscode-font-size);
            color: var(--vscode-foreground);
            background-color: var(--vscode-editor-background);
            padding: 16px;
            margin: 0;
        }
        
        .api-header {
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--vscode-panel-border);
        }
        
        .api-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .api-status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        
        .status-healthy {
            background: rgba(0, 255, 0, 0.2);
            color: var(--vscode-terminal-ansiGreen);
        }
        
        .status-unhealthy {
            background: rgba(255, 0, 0, 0.2);
            color: var(--vscode-terminal-ansiRed);
        }
        
        .status-checking {
            background: rgba(255, 255, 0, 0.2);
            color: var(--vscode-terminal-ansiYellow);
        }
        
        .api-actions {
            margin: 12px 0;
        }
        
        .btn {
            background: var(--vscode-button-background);
            color: var(--vscode-button-foreground);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
            font-size: 12px;
        }
        
        .btn:hover {
            background: var(--vscode-button-hoverBackground);
        }
        
        .btn-secondary {
            background: var(--vscode-button-secondaryBackground);
            color: var(--vscode-button-secondaryForeground);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 8px 16px;
            margin-bottom: 20px;
            font-size: 13px;
        }
        
        .info-label {
            font-weight: 500;
            color: var(--vscode-descriptionForeground);
        }
        
        .changelog-section {
            margin-top: 20px;
        }
        
        .changelog-item {
            padding: 12px;
            border: 1px solid var(--vscode-panel-border);
            border-radius: 6px;
            margin-bottom: 8px;
        }
        
        .changelog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .changelog-type {
            font-weight: 500;
            font-size: 12px;
        }
        
        .changelog-date {
            font-size: 11px;
            color: var(--vscode-descriptionForeground);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--vscode-descriptionForeground);
        }
        
        .error {
            color: var(--vscode-errorForeground);
            background: var(--vscode-inputValidation-errorBackground);
            border: 1px solid var(--vscode-inputValidation-errorBorder);
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="content">
        <div class="loading">Select an API to view details</div>
    </div>

    <script>
        const vscode = acquireVsCodeApi();
        let currentData = {};

        window.addEventListener('message', event => {
            const message = event.data;
            handleMessage(message);
        });

        function handleMessage(message) {
            switch (message.type) {
                case 'apiDetailData':
                    currentData = message.data;
                    renderApiDetail();
                    break;
                case 'error':
                    showError(message.error);
                    break;
                case 'apiChecked':
                    showSuccess('API check initiated');
                    break;
                case 'statusToggled':
                    showSuccess('Status updated');
                    break;
            }
        }

        function renderApiDetail() {
            const api = currentData.api || {};
            const changelogs = currentData.changelogs || [];
            const issues = currentData.issues || [];
            
            const content = document.getElementById('content');
            content.innerHTML = \`
                <div class="api-header">
                    <div class="api-title">\${api.apiName || 'Unknown API'}</div>
                    <div class="api-status status-\${api.healthStatus || 'unknown'}">\${api.healthStatus || 'unknown'}</div>
                    <div style="font-size: 13px; color: var(--vscode-descriptionForeground);">
                        \${api.description || 'No description'}
                    </div>
                </div>
                
                <div class="api-actions">
                    <button class="btn" onclick="checkApi()">Check Now</button>
                    <button class="btn btn-secondary" onclick="toggleStatus()">\${api.isActive ? 'Pause' : 'Resume'}</button>
                    <button class="btn btn-secondary" onclick="refresh()">Refresh</button>
                </div>
                
                <div class="info-grid">
                    <span class="info-label">Type:</span>
                    <span>\${api.type || 'Unknown'}</span>
                    
                    <span class="info-label">Version:</span>
                    <span>\${api.version || 'N/A'}</span>
                    
                    <span class="info-label">URL:</span>
                    <span>\${api.url || 'N/A'}</span>
                    
                    <span class="info-label">Last Checked:</span>
                    <span>\${api.lastChecked ? new Date(api.lastChecked).toLocaleString() : 'Never'}</span>
                    
                    <span class="info-label">Status:</span>
                    <span>\${api.isActive ? 'Active' : 'Inactive'}</span>
                </div>
                
                <div class="changelog-section">
                    <h3>Recent Changes</h3>
                    \${changelogs.length > 0 ? 
                        changelogs.map(change => \`
                            <div class="changelog-item">
                                <div class="changelog-header">
                                    <span class="changelog-type">\${change.changeType || 'Change'}</span>
                                    <span class="changelog-date">\${new Date(change.detectedAt).toLocaleString()}</span>
                                </div>
                                <div>\${change.description || 'No description'}</div>
                            </div>
                        \`).join('') :
                        '<div style="color: var(--vscode-descriptionForeground); font-style: italic;">No recent changes</div>'
                    }
                </div>
                
                <div class="changelog-section" id="issues-section" style="margin-top:16px;">
                    <h3>Active Issues</h3>
                    \${issues.length > 0 ? issues.map(iss => \`
                        <div class="changelog-item">
                            <div class="changelog-header">
                                <span class="changelog-type">\${(iss.severity || iss.priority || 'medium').toString().toUpperCase()}</span>
                                <span class="changelog-date">\${new Date(iss.timestamp || iss.createdAt || Date.now()).toLocaleString()}</span>
                            </div>
                            <div><strong>\${iss.title || 'Issue'}</strong></div>
                            <div style="font-size:12px; color: var(--vscode-descriptionForeground)">\${iss.description || ''}</div>
                        </div>
                    \`).join('') : '<div style="color: var(--vscode-descriptionForeground); font-style: italic;">No active issues</div>'}
                </div>
            \`;
        }

        function checkApi() {
            vscode.postMessage({ type: 'checkApi' });
        }

        function toggleStatus() {
            vscode.postMessage({ type: 'toggleStatus' });
        }

        function refresh() {
            vscode.postMessage({ type: 'refreshDetail' });
        }

        function showError(message) {
            const content = document.getElementById('content');
            content.innerHTML = \`<div class="error">\${message}</div>\` + content.innerHTML;
        }

        function showSuccess(message) {
            const content = document.getElementById('content');
            const successDiv = document.createElement('div');
            successDiv.className = 'error';
            successDiv.style.background = 'rgba(0, 255, 0, 0.1)';
            successDiv.style.borderColor = 'rgba(0, 255, 0, 0.3)';
            successDiv.style.color = 'var(--vscode-terminal-ansiGreen)';
            successDiv.textContent = message;
            content.insertBefore(successDiv, content.firstChild);
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }
    </script>
</body>
</html>`;
    }
}
```

## File Context Menu Handler (handlers/FileContextMenuHandler.ts)

```typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { APIService } from '../services/APIService';
import { FileSystemService } from '../services/FileSystemService';

export class FileContextMenuHandler {
    constructor(
        private readonly apiService: APIService,
        private readonly fileSystemService: FileSystemService
    ) {}

    public registerCommands(context: vscode.ExtensionContext): void {
        // Register API from file
        const registerApiCommand = vscode.commands.registerCommand(
            'apilens.registerApiFromFile',
            async (uri: vscode.Uri) => {
                await this.registerApiFromFile(uri);
            }
        );

        // Import OpenAPI spec
        const importSpecCommand = vscode.commands.registerCommand(
            'apilens.importOpenApiSpec',
            async (uri: vscode.Uri) => {
                await this.importOpenApiSpec(uri);
            }
        );

        // Validate OpenAPI spec
        const validateSpecCommand = vscode.commands.registerCommand(
            'apilens.validateOpenApiSpec',
            async (uri: vscode.Uri) => {
                await this.validateOpenApiSpec(uri);
            }
        );

        // Preview OpenAPI spec
        const previewSpecCommand = vscode.commands.registerCommand(
            'apilens.previewOpenApiSpec',
            async (uri: vscode.Uri) => {
                await this.previewOpenApiSpec(uri);
            }
        );

        context.subscriptions.push(
            registerApiCommand,
            importSpecCommand,
            validateSpecCommand,
            previewSpecCommand
        );
    }

    private async registerApiFromFile(uri: vscode.Uri): Promise<void> {
        try {
            const filePath = uri.fsPath;
            const fileName = path.basename(filePath);
            
            const isValidSpec = await this.fileSystemService.validateOpenApiFile(filePath);
            if (!isValidSpec) {
                vscode.window.showErrorMessage(`${fileName} is not a valid OpenAPI specification`);
                return;
            }

            const spec = await this.fileSystemService.parseOpenApiFile(filePath);
            
            const apiName = await vscode.window.showInputBox({
                prompt: 'Enter API name',
                value: spec.info?.title || fileName.replace(/\.(json|ya?ml)$/i, ''),
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return 'API name is required';
                    }
                    return null;
                }
            });

            if (!apiName) {
                return;
            }

            const baseUrl = await vscode.window.showInputBox({
                prompt: 'Enter base URL for the API',
                value: spec.servers?.[0]?.url || 'http://localhost:3000',
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return 'Base URL is required';
                    }
                    try {
                        new URL(value);
                        return null;
                    } catch {
                        return 'Invalid URL format';
                    }
                }
            });

            if (!baseUrl) {
                return;
            }

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Registering API...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: 'Uploading specification...' });

                const apiData = {
                    apiName: apiName.trim(),
                    url: baseUrl.trim(),
                    description: spec.info?.description || '',
                    version: spec.info?.version || '1.0.0',
                    type: 'openapi',
                    isActive: true,
                    openApiSpec: spec
                };

                progress.report({ increment: 50, message: 'Creating API registration...' });

                const result = await this.apiService.createApi(apiData);
                
                progress.report({ increment: 100, message: 'API registered successfully!' });

                vscode.window.showInformationMessage(
                    `API "${apiName}" registered successfully!`,
                    'View API'
                ).then(selection => {
                    if (selection === 'View API') {
                        vscode.commands.executeCommand('apilens.showApiDetail', result.id);
                    }
                });
            });

        } catch (error: any) {
            console.error('VS Code Extension: Error registering API from file:', error);
            vscode.window.showErrorMessage(`Failed to register API: ${error.message}`);
        }
    }

    private async importOpenApiSpec(uri: vscode.Uri): Promise<void> {
        try {
            const filePath = uri.fsPath;
            const fileName = path.basename(filePath);
            
            const apis = await this.apiService.getApis({ limit: 100 });
            
            if (apis.length === 0) {
                vscode.window.showInformationMessage(
                    'No APIs found. Register an API first.',
                    'Register API'
                ).then(selection => {
                    if (selection === 'Register API') {
                        this.registerApiFromFile(uri);
                    }
                });
                return;
            }

            const selectedApi = await vscode.window.showQuickPick(
                apis.map(api => ({
                    label: api.apiName || api.name || 'Unknown API',
                    description: api.url,
                    detail: api.description,
                    api
                })),
                {
                    placeHolder: 'Select API to import specification into',
                    matchOnDescription: true,
                    matchOnDetail: true
                }
            );

            if (!selectedApi) {
                return;
            }

            const spec = await this.fileSystemService.parseOpenApiFile(filePath);

            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Importing specification...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: 'Validating specification...' });

                const isValid = await this.fileSystemService.validateOpenApiFile(filePath);
                if (!isValid) {
                    throw new Error('Invalid OpenAPI specification');
                }

                progress.report({ increment: 50, message: 'Updating API...' });

                await this.apiService.updateApi(selectedApi.api.id, {
                    openApiSpec: spec,
                    version: spec.info?.version || selectedApi.api.version
                });

                progress.report({ increment: 100, message: 'Specification imported successfully!' });

                vscode.window.showInformationMessage(
                    `OpenAPI specification imported into "${selectedApi.label}"`,
                    'View API'
                ).then(selection => {
                    if (selection === 'View API') {
                        vscode.commands.executeCommand('apilens.showApiDetail', selectedApi.api.id);
                    }
                });
            });

        } catch (error: any) {
            console.error('VS Code Extension: Error importing OpenAPI spec:', error);
            vscode.window.showErrorMessage(`Failed to import specification: ${error.message}`);
        }
    }

    private async validateOpenApiSpec(uri: vscode.Uri): Promise<void> {
        try {
            const filePath = uri.fsPath;
            const fileName = path.basename(filePath);
            
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'Validating OpenAPI specification...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: 'Reading file...' });

                const isValid = await this.fileSystemService.validateOpenApiFile(filePath);
                
                progress.report({ increment: 50, message: 'Analyzing specification...' });

                if (isValid) {
                    const spec = await this.fileSystemService.parseOpenApiFile(filePath);
                    
                    progress.report({ increment: 100, message: 'Validation complete!' });
                    
                    const pathCount = Object.keys(spec.paths || {}).length;
                    const version = spec.info?.version || 'Unknown';
                    const title = spec.info?.title || fileName;
                    
                    vscode.window.showInformationMessage(
                        `✅ Valid OpenAPI specification: "${title}" (v${version}) with ${pathCount} paths`,
                        'Register API'
                    ).then(selection => {
                        if (selection === 'Register API') {
                            this.registerApiFromFile(uri);
                        }
                    });
                } else {
                    progress.report({ increment: 100, message: 'Validation failed!' });
                    vscode.window.showErrorMessage(`❌ Invalid OpenAPI specification in ${fileName}`);
                }
            });

        } catch (error: any) {
            console.error('VS Code Extension: Error validating OpenAPI spec:', error);
            vscode.window.showErrorMessage(`Validation failed: ${error.message}`);
        }
    }

    private async previewOpenApiSpec(uri: vscode.Uri): Promise<void> {
        try {
            const filePath = uri.fsPath;
            const fileName = path.basename(filePath);
            
            const spec = await this.fileSystemService.parseOpenApiFile(filePath);
            
            // Create a new document with formatted JSON
            const content = JSON.stringify(spec, null, 2);
            const doc = await vscode.workspace.openTextDocument({
                content,
                language: 'json'
            });
            
            await vscode.window.showTextDocument(doc, {
                preview: true,
                viewColumn: vscode.ViewColumn.Beside
            });
            
            // Show summary information
            const pathCount = Object.keys(spec.paths || {}).length;
            const version = spec.info?.version || 'Unknown';
            const title = spec.info?.title || fileName;
            
            vscode.window.showInformationMessage(
                `OpenAPI Preview: "${title}" (v${version}) - ${pathCount} endpoints`,
                'Register API',
                'Validate'
            ).then(selection => {
                if (selection === 'Register API') {
                    this.registerApiFromFile(uri);
                } else if (selection === 'Validate') {
                    this.validateOpenApiSpec(uri);
                }
            });

        } catch (error: any) {
            console.error('VS Code Extension: Error previewing OpenAPI spec:', error);
            vscode.window.showErrorMessage(`Failed to preview specification: ${error.message}`);
        }
    }
}
```

## File System Service (services/FileSystemService.ts)

```typescript
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';

export interface OpenApiFile {
    path: string;
    name: string;
    size: number;
    lastModified: Date;
    isValid: boolean;
    spec?: any;
}

export class FileSystemService implements vscode.Disposable {
    private fileWatcher?: vscode.FileSystemWatcher;
    private _onFileChanged = new vscode.EventEmitter<vscode.Uri>();
    public readonly onFileChanged = this._onFileChanged.event;

    private _onFileAdded = new vscode.EventEmitter<vscode.Uri>();
    public readonly onFileAdded = this._onFileAdded.event;

    private _onFileDeleted = new vscode.EventEmitter<vscode.Uri>();
    public readonly onFileDeleted = this._onFileDeleted.event;

    constructor() {
        this.initializeFileWatcher();
    }

    private initializeFileWatcher(): void {
        // Watch for OpenAPI specification files
        this.fileWatcher = vscode.workspace.createFileSystemWatcher(
            '**/*.{json,yaml,yml}',
            false, 
            false,
            false  
        );

        this.fileWatcher.onDidCreate(async (uri) => {
            if (await this.isOpenApiFile(uri.fsPath)) {
                this._onFileAdded.fire(uri);
                
                const fileName = path.basename(uri.fsPath);
                vscode.window.showInformationMessage(
                    `OpenAPI specification detected: ${fileName}`,
                    'Register API',
                    'Validate'
                ).then(selection => {
                    if (selection === 'Register API') {
                        vscode.commands.executeCommand('apilens.registerApiFromFile', uri);
                    } else if (selection === 'Validate') {
                        vscode.commands.executeCommand('apilens.validateOpenApiSpec', uri);
                    }
                });
            }
        });

        this.fileWatcher.onDidChange(async (uri) => {
            if (await this.isOpenApiFile(uri.fsPath)) {
                this._onFileChanged.fire(uri);
            }
        });

        this.fileWatcher.onDidDelete((uri) => {
            this._onFileDeleted.fire(uri);
        });
    }

    async findOpenApiFiles(): Promise<OpenApiFile[]> {
        const files: OpenApiFile[] = [];
        
        if (!vscode.workspace.workspaceFolders) {
            return files;
        }

        for (const folder of vscode.workspace.workspaceFolders) {
            const pattern = new vscode.RelativePattern(folder, '**/*.{json,yaml,yml}');
            const uris = await vscode.workspace.findFiles(pattern, null, 100);
            
            for (const uri of uris) {
                try {
                    const filePath = uri.fsPath;
                    const isValid = await this.isOpenApiFile(filePath);
                    
                    if (isValid) {
                        const stats = await fs.promises.stat(filePath);
                        const spec = await this.parseOpenApiFile(filePath);
                        
                        files.push({
                            path: filePath,
                            name: path.basename(filePath),
                            size: stats.size,
                            lastModified: stats.mtime,
                            isValid: true,
                            spec
                        });
                    }
                } catch (error) {
                    console.warn(`VS Code Extension: Error processing file ${uri.fsPath}:`, error);
                }
            }
        }
        
        return files;
    }

    async isOpenApiFile(filePath: string): Promise<boolean> {
        try {
            const content = await fs.promises.readFile(filePath, 'utf8');
            const data = this.parseContent(content, filePath);
            
            return this.isValidOpenApiSpec(data);
        } catch (error) {
            return false;
        }
    }

    async validateOpenApiFile(filePath: string): Promise<boolean> {
        try {
            const spec = await this.parseOpenApiFile(filePath);
            return this.isValidOpenApiSpec(spec);
        } catch (error) {
            console.error(`VS Code Extension: Error validating OpenAPI file ${filePath}:`, error);
            return false;
        }
    }

    async parseOpenApiFile(filePath: string): Promise<any> {
        const content = await fs.promises.readFile(filePath, 'utf8');
        return this.parseContent(content, filePath);
    }

    private parseContent(content: string, filePath: string): any {
        const ext = path.extname(filePath).toLowerCase();
        
        if (ext === '.json') {
            return JSON.parse(content);
        } else if (ext === '.yaml' || ext === '.yml') {
            return yaml.load(content);
        } else {
            throw new Error(`Unsupported file format: ${ext}`);
        }
    }

    private isValidOpenApiSpec(data: any): boolean {
        if (!data || typeof data !== 'object') {
            return false;
        }

        // Check for OpenAPI version
        const hasOpenApi = data.openapi && typeof data.openapi === 'string';
        const hasSwagger = data.swagger && typeof data.swagger === 'string';
        
        if (!hasOpenApi && !hasSwagger) {
            return false;
        }

        // Check for required fields
        if (!data.info || typeof data.info !== 'object') {
            return false;
        }

        if (!data.info.title || typeof data.info.title !== 'string') {
            return false;
        }

        if (!data.info.version || typeof data.info.version !== 'string') {
            return false;
        }

        // Check for paths (optional but common)
        if (data.paths && typeof data.paths !== 'object') {
            return false;
        }

        return true;
    }

    async getFileContent(filePath: string): Promise<string> {
        return await fs.promises.readFile(filePath, 'utf8');
    }

    async writeFileContent(filePath: string, content: string): Promise<void> {
        const dir = path.dirname(filePath);
        await fs.promises.mkdir(dir, { recursive: true });
        await fs.promises.writeFile(filePath, content, 'utf8');
    }

    async fileExists(filePath: string): Promise<boolean> {
        try {
            await fs.promises.access(filePath, fs.constants.F_OK);
            return true;
        } catch {
            return false;
        }
    }

    async getFileStats(filePath: string): Promise<fs.Stats> {
        return await fs.promises.stat(filePath);
    }

    getRelativePath(filePath: string): string {
        if (!vscode.workspace.workspaceFolders) {
            return filePath;
        }

        for (const folder of vscode.workspace.workspaceFolders) {
            if (filePath.startsWith(folder.uri.fsPath)) {
                return path.relative(folder.uri.fsPath, filePath);
            }
        }

        return filePath;
    }

    async showFileInExplorer(filePath: string): Promise<void> {
        const uri = vscode.Uri.file(filePath);
        await vscode.commands.executeCommand('revealFileInOS', uri);
    }

    async openFileInEditor(filePath: string): Promise<void> {
        const uri = vscode.Uri.file(filePath);
        const document = await vscode.workspace.openTextDocument(uri);
        await vscode.window.showTextDocument(document);
    }

    dispose(): void {
        if (this.fileWatcher) {
            this.fileWatcher.dispose();
        }
        this._onFileChanged.dispose();
        this._onFileAdded.dispose();
        this._onFileDeleted.dispose();
    }
}
```

## Router System (lib/router.ts)

```typescript
export interface RouteParams {
    [key: string]: string | undefined;
}

export type RouteChangeHandler = (route: string, params: RouteParams) => void;

class Router {
    private currentRoute: string = '/';
    private currentParams: RouteParams = {};
    private listeners: RouteChangeHandler[] = [];

    public getCurrentRoute(): string {
        return this.currentRoute;
    }

    public getCurrentParams(): RouteParams {
        return { ...this.currentParams };
    }

    public navigate(route: string, params: RouteParams = {}): void {
        const oldRoute = this.currentRoute;
        const oldParams = this.currentParams;

        this.currentRoute = route;
        this.currentParams = { ...params };

        if (oldRoute !== route || JSON.stringify(oldParams) !== JSON.stringify(params)) {
            this.notifyListeners();
        }
    }

    public onRouteChange(handler: RouteChangeHandler): () => void {
        this.listeners.push(handler);
        
        // Return unsubscribe function
        return () => {
            const index = this.listeners.indexOf(handler);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }

    private notifyListeners(): void {
        this.listeners.forEach(listener => {
            try {
                listener(this.currentRoute, this.currentParams);
            } catch (error) {
                console.error('Error in route change handler:', error);
            }
        });
    }

    public dispose(): void {
        this.listeners = [];
        this.currentRoute = '/';
        this.currentParams = {};
    }
}

export const router = new Router();
```

## WebSocket Service (services/WebSocketService.ts)

```typescript
import * as vscode from 'vscode';
import { io, Socket } from 'socket.io-client';
import { APIService } from './APIService';

export interface WebSocketEventData {
    apiId: string;
    apiName: string;
    status?: string;
    changeType?: string;
    timestamp: string;
}

export class WebSocketService {
    private socket: Socket | null = null;
    private context: vscode.ExtensionContext;
    private apiService: APIService;
    private eventListeners: Map<string, ((data: any) => void)[]> = new Map();

    constructor(context: vscode.ExtensionContext, apiService: APIService) {
        this.context = context;
        this.apiService = apiService;
    }

    async connect(): Promise<void> {
        const config = vscode.workspace.getConfiguration('apilens');
        const enableRealtime = config.get('enableRealtime', true);
        
        if (!enableRealtime) {
            return;
        }

        const apiUrl = config.get('apiUrl', 'http://localhost:3000');
        
        try {
            this.socket = io(apiUrl, {
                transports: ['websocket', 'polling']
            });

            this.socket.on('connect', () => {});

            this.socket.on('disconnect', () => {});

            this.socket.on('api-change', (data: WebSocketEventData) => {
                this.emit('api-change', data);
            });

            this.socket.on('api-health-change', (data: WebSocketEventData) => {
                this.emit('api-health-change', data);
            });

            this.socket.on('api-created', (data: WebSocketEventData) => {
                this.emit('api-created', data);
            });

            this.socket.on('api-deleted', (data: WebSocketEventData) => {
                this.emit('api-deleted', data);
            });

            this.socket.on('connect_error', (error) => {
                // Handle connection errors silently
            });

        } catch (error) {
            // Handle connection failures silently
        }
    }

    disconnect(): void {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
        }
        this.eventListeners.clear();
    }

    on(event: string, callback: (data: any) => void): void {
        if (!this.eventListeners.has(event)) {
            this.eventListeners.set(event, []);
        }
        this.eventListeners.get(event)!.push(callback);
    }

    off(event: string, callback?: (data: any) => void): void {
        if (!this.eventListeners.has(event)) {
            return;
        }

        if (callback) {
            const listeners = this.eventListeners.get(event)!;
            const index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        } else {
            this.eventListeners.delete(event);
        }
    }

    private emit(event: string, data: any): void {
        const listeners = this.eventListeners.get(event);
        if (listeners) {
            listeners.forEach(callback => {
                try {
                    callback(data);
                } catch (error) {
                    // Handle callback errors silently
                }
            });
        }
    }

    isConnected(): boolean {
        return this.socket ? this.socket.connected : false;
    }

    getConnectionStatus(): string {
        if (!this.socket) {
            return 'disconnected';
        }
        return this.socket.connected ? 'connected' : 'connecting';
    }
}
```

## Summary

The APILens VSCode Extension provides comprehensive API monitoring capabilities directly within Visual Studio Code:

- **Dashboard**: Real-time API monitoring with health status and analytics
- **File Integration**: Context menu actions for OpenAPI files with validation
- **Real-time Updates**: WebSocket integration for live API changes
- **Professional UI**: Rich webview interface with VS Code theming
- **Status Bar**: Live stats display with quick access

The extension integrates seamlessly with the APILens backend to provide instant visibility into API changes and performance metrics.
```
                if (config.get('showNotifications')) {
                    vscode.window.showInformationMessage(
                        `API "${data.api.apiName || data.api.name}" has been updated`,
                        'View Changes'
                    ).then(selection => {
                        if (selection === 'View Changes') {
                            vscode.commands.executeCommand('apilens.viewChanges');
                        }
                    });
                }
            });

            // Health status updates
            this.socket.on('health_update', (data: { apiId: string; health: string; details?: any }) => {
                console.log('VS Code Extension: Received health update:', data);
                this._onMessage.fire({
                    type: 'health_update',
                    data,
                    timestamp: new Date().toISOString()
                });

                if (data.health === 'error' || data.health === 'unhealthy') {
                    const config = vscode.workspace.getConfiguration('apilens');
                    if (config.get('showNotifications')) {
                        vscode.window.showWarningMessage(
                            `API health issue detected`,
                            'View Details'
                        ).then(selection => {
                            if (selection === 'View Details') {
                                vscode.commands.executeCommand('apilens.showApiDetail', data.apiId);
                            }
                        });
                    }
                }
            });

            // New notifications
            this.socket.on('notification', (data: Notification) => {
                console.log('VS Code Extension: Received notification:', data);
                this._onMessage.fire({
                    type: 'notification',
                    data,
                    timestamp: new Date().toISOString()
                });

                const config = vscode.workspace.getConfiguration('apilens');
                if (config.get('showNotifications')) {
                    this.showNotification(data);
                }
            });

            // Status updates
            this.socket.on('status_update', (data: any) => {
                console.log('VS Code Extension: Received status update:', data);
                this._onMessage.fire({
                    type: 'status_update',
                    data,
                    timestamp: new Date().toISOString()
                });
            });

            // Authentication required
            this.socket.on('auth_required', () => {
                console.log('VS Code Extension: Authentication required for WebSocket');
                vscode.window.showWarningMessage(
                    'Authentication required for real-time updates',
                    'Authenticate'
                ).then(selection => {
                    if (selection === 'Authenticate') {
                        vscode.commands.executeCommand('apilens.openPanel');
                    }
                });
            });

            // Error handling
            this.socket.on('error', (error) => {
                console.error('VS Code Extension: WebSocket error:', error);
            });
        });
    }

    private attemptReconnect(): void {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.log('VS Code Extension: Max reconnection attempts reached');
            vscode.window.showWarningMessage('Lost connection to APILens. Real-time updates disabled.');
            return;
        }

        this.reconnectAttempts++;
        console.log(`VS Code Extension: Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);

        setTimeout(() => {
            if (this.socket) {
                this.socket.connect();
            }
        }, this.reconnectDelay * this.reconnectAttempts);
    }

    private showNotification(notification: Notification): void {
        const actions = notification.actions?.map(action => action.label) || [];
        
        let showMethod;
        switch (notification.type) {
            case 'error':
                showMethod = vscode.window.showErrorMessage;
                break;
            case 'warning':
                showMethod = vscode.window.showWarningMessage;
                break;
            default:
                showMethod = vscode.window.showInformationMessage;
        }

        showMethod(notification.message, ...actions).then(selection => {
            if (selection && notification.actions) {
                const action = notification.actions.find(a => a.label === selection);
                if (action) {
                    vscode.commands.executeCommand(action.command, ...(action.args || []));
                }
            }
        });
    }

    public emit(event: string, data: any): void {
        if (this.socket && this.isConnected) {
            this.socket.emit(event, data);
        } else {
            console.warn('VS Code Extension: Cannot emit event: WebSocket not connected');
        }
    }

    public getConnectionStatus(): boolean {
        return this.isConnected;
    }

    public disconnect(): void {
        if (this.socket) {
            this.socket.disconnect();
            this.socket = null;
            this.isConnected = false;
            this._onConnectionChange.fire(false);
        }
    }

    public dispose(): void {
        console.log('VS Code Extension: Disposing WebSocket service');
        this.disconnect();
        this._onMessage.dispose();
        this._onConnectionChange.dispose();
    }
// end of vscode code